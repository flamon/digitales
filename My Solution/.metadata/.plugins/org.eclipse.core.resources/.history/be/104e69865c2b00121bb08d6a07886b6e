ANSI-C/cC++ Compiler for HC08 V-5.0.39 Build 11346, Dec 13 2011

    1:  /*****************************************************************************
    2:  * SMAC implementation.
    3:  * 
    4:  * Copyright (c) 2009, Freescale, Inc. All rights reserved.
    5:  *
    6:  * No part of this document must be reproduced in any form - including copied,
    7:  * transcribed, printed or by any electronic means - without specific written
    8:  * permission from Freescale Semiconductor.
    9:  *
   10:  *****************************************************************************/
   11:  
   12:  #include "SMAC.h"
   13:  
   14:  
   15:  /************************************************************************************
   16:  *************************************************************************************
   17:  * Private memory declarations
   18:  *************************************************************************************
   19:  ************************************************************************************/
   20:  
   21:  const uint8_t au8SmacVersion[7] = 
   22:  {
   23:    mMajorSmacV_c, 
   24:    mMiddleSmacV_c, 
   25:    mMinorSmacV_c, 
   26:    mMonthSmacV_c,
   27:    mDaySmacV_c, 
   28:    mYearSmacV_c, 
   29:    mConsSmacV_c
   30:  };
   31:                                  
   32:  static uint32_t        smacTimeout;
   33:  static uint16_t        smacChannelsBeingScanned;
   34:  static uint8_t         smacEdValue;
   35:  static smacStates_t    smacState;
   36:  static phyRxParams_t   smacLastDataRxParams;
   37:  static channels_t      smacCurrentChannel;
   38:  static channels_t      smacScanCurrentChannel;
   39:  static channels_t      smacClearestChann;
   40:  static uint8_t         u8TestBuffer[65] = 
   41:  { 
   42:    0x42,
   43:    0xff,0xc1,0xfb,0xe8,0x4c,0x90,0x72,0x8b,0xe7,0xb3,0x51,0x89,0x63,0xab,0x23,0x23,  
   44:    0x02,0x84,0x18,0x72,0xaa,0x61,0x2f,0x3b,0x51,0xa8,0xe5,0x37,0x49,0xfb,0xc9,0xca,
   45:    0x0c,0x18,0x53,0x2c,0xfd,0x45,0xe3,0x9a,0xe6,0xf1,0x5d,0xb0,0xb6,0x1b,0xb4,0xbe,
   46:    0x2a,0x50,0xea,0xe9,0x0e,0x9c,0x4b,0x5e,0x57,0x24,0xcc,0xa1,0xb7,0x59,0xb8,0x87
   47:  };
   48:  static phyPacket_t     *pTestPacket;  
   49:  
   50:  volatile static prssPacketPtr_t smacProccesPacketPtr;
   51:  
   52:  flagsRegister_t smacFlags;
   53:  
   54:  /************************************************************************************
   55:  *************************************************************************************
   56:  * Interface functions
   57:  *************************************************************************************
   58:  ************************************************************************************/
   59:  
   60:  
   61:  /***********************************************************************************/
   62:  /******************************** SMAC Data primitives *****************************/
   63:  /***********************************************************************************/
   64:  
   65:  /************************************************************************************
   66:  * MCPSDataRequest
   67:  * 
   68:  * This data primitive is used to send an over the air packet. This is an asyncronous 
   69:  * function,  it means it ask SMAC to transmit one OTA packet,  but when the runction 
   70:  * returns it is not sent already.
   71:  *
   72:  ************************************************************************************/
   73:  smacErrors_t MCPSDataRequest
   74:  (
   75:  txPacket_t *psTxPacket //IN:Pointer to the packet to be transmitted
   76:  )
   77:  {
   78:    
   79:    uint8_t u8PhyRes = 0; 
   80:    
   81:  #if(TRUE == smacParametersValidation_d)
   82:    uint8_t u8MaxLen=0;
   83:    
   84:    if (mPromiscuousModeEnabled)
  0000 c60000   [4]             LDA   smacFlags
  0003 a501     [2]             BIT   #1
  0005 2703     [3]             BEQ   LA ;abs = 000a
   85:    {
   86:      u8MaxLen = gMaxPromiscuousSmacSDULenght_c;
   87:    }
  0007 a67d     [2]             LDA   #125
  0009 65       [3]             SKIP2 LC ;abs = 000c
  000a          LA:     
   88:    else
   89:    {
   90:      u8MaxLen = gMaxSmacSDULenght_c;
   91:    }
  000a a67b     [2]             LDA   #123
  000c          LC:     
   92:    
   93:    if((NULL == psTxPacket) || (u8MaxLen < psTxPacket->u8DataLength))
  000c 650000   [3]             CPHX  #0
  000f 2703     [3]             BEQ   L14 ;abs = 0014
  0011 f1       [3]             CMP   ,X
  0012 2403     [3]             BCC   L17 ;abs = 0017
  0014          L14:    
   94:    {
   95:      return gErrorOutOfRange_c;
  0014 a602     [2]             LDA   #2
  0016 8d       [7]             RTC   
  0017          L17:    
   96:    }
   97:    
   98:  #endif
   99:  
  100:  #if(TRUE == smacInitializationValidation_d)
  101:   if(FALSE == mSmacInitialized)
  0017 c60000   [4]             LDA   smacFlags
  001a a502     [2]             BIT   #2
  001c 2603     [3]             BNE   L21 ;abs = 0021
  102:    {
  103:      return gErrorNoValidCondition_c;
  001e a604     [2]             LDA   #4
  0020 8d       [7]             RTC   
  0021          L21:    
  104:    }
  105:  #endif
  106:    if(mSmacStateIdle_c != smacState)
  0021 c60000   [4]             LDA   smacState
  0024 2703     [3]             BEQ   L29 ;abs = 0029
  107:    {
  108:      return gErrorBusy_c;
  0026 a601     [2]             LDA   #1
  0028 8d       [7]             RTC   
  0029          L29:    
  109:    }
  110:    
  111:    smacProccesPacketPtr.smacTxPacketPointer  = SmacFormatTxPacket(psTxPacket);
  0029 ac000000 [8]             CALL  SmacFormatTxPacket
  002d 960000   [5]             STHX  smacProccesPacketPtr
  112:  
  113:    u8PhyRes = PhyPdDataRequest(smacProccesPacketPtr.smacTxPacketPointer, gDataReq_NoAck_NoCca_Unslotted_c, NULL);
  0030 320000   [5]             LDHX  smacProccesPacketPtr
  0033 89       [2]             PSHX  
  0034 8b       [2]             PSHH  
  0035 a601     [2]             LDA   #1
  0037 5f       [1]             CLRX  
  0038 8c       [1]             CLRH  
  0039 cd0000   [6]             JSR   PhyPdDataRequest
  003c a702     [2]             AIS   #2
  114:  
  115:    if(!u8PhyRes)
  003e 4d       [1]             TSTA  
  003f 2607     [3]             BNE   L48 ;abs = 0048
  116:    {
  117:      smacState= mSmacStateTransmitting_c; 
  0041 a601     [2]             LDA   #1
  0043 c70000   [4]             STA   smacState
  118:      return gErrorNoError_c;
  0046 4f       [1]             CLRA  
  0047 8d       [7]             RTC   
  0048          L48:    
  119:    }
  120:    else
  121:    {
  122:      return gErrorNoResourcesAvailable_c;
  0048 a603     [2]             LDA   #3
  123:    }
  124:  }
  004a 8d       [7]             RTC   
  125:  
  126:  
  127:  /************************************************************************************
  128:  * MLMERXEnableRequest
  129:  * 
  130:  * Function used to place the radio into receive mode 
  131:  *
  132:  ************************************************************************************/
  133:  smacErrors_t MLMERXEnableRequest
  134:  (
  135:  rxPacket_t *gsRxPacket, //OUT: Pointer to the structure where the reception results 
  136:                          //     will be stored.
  137:  uint32_t u32Timeout     //IN:  32-bit timeout value, this is directly the value that 
  138:                          //     is stored on the Radio's timer register.
  139:  )
  140:  {
  0000 a7fe     [2]             AIS   #-2
  141:  
  142:    uint8_t u8PhyRes = 0; 
  143:    phyPacket_t * pAuxPacket;
  144:  
  145:  #if(TRUE == smacParametersValidation_d)
  146:    uint8_t u8MaxLen=0;
  147:  #endif
  148:    
  149:    if (mPromiscuousModeEnabled)
  0002 c60000   [4]             LDA   smacFlags
  0005 a501     [2]             BIT   #1
  0007 270c     [3]             BEQ   L15 ;abs = 0015
  150:    {
  151:  #if(TRUE == smacParametersValidation_d)
  152:      u8MaxLen = gMaxPromiscuousSmacSDULenght_c;
  153:  #endif
  154:      pAuxPacket = (phyPacket_t *)&gsRxPacket->smacPdu.reserved[1]; 
  0009 9efe0a   [5]             LDHX  10,SP
  000c af04     [2]             AIX   #4
  000e 9eff01   [5]             STHX  1,SP
  155:    }
  0011 a67d     [2]             LDA   #125
  0013 200a     [3]             BRA   L1F ;abs = 001f
  0015          L15:    
  156:    else
  157:    {
  158:  #if(TRUE == smacParametersValidation_d)
  159:      u8MaxLen = gMaxSmacSDULenght_c;
  160:  #endif
  161:      pAuxPacket = (phyPacket_t *)&gsRxPacket->u8DataLength; 
  0015 9efe0a   [5]             LDHX  10,SP
  0018 af02     [2]             AIX   #2
  001a 9eff01   [5]             STHX  1,SP
  162:    }
  001d a67b     [2]             LDA   #123
  001f          L1F:    
  163:    
  164:  #if(TRUE == smacParametersValidation_d)
  165:    if((NULL == gsRxPacket) || (u8MaxLen < gsRxPacket->u8MaxDataLength))
  001f 9efe0a   [5]             LDHX  10,SP
  0022 2703     [3]             BEQ   L27 ;abs = 0027
  0024 f1       [3]             CMP   ,X
  0025 2404     [3]             BCC   L2B ;abs = 002b
  0027          L27:    
  166:    {
  167:      return gErrorOutOfRange_c;
  0027 a602     [2]             LDA   #2
  0029 206c     [3]             BRA   L97 ;abs = 0097
  002b          L2B:    
  168:    }
  169:  #endif
  170:    
  171:  
  172:  
  173:  #if(TRUE == smacInitializationValidation_d)
  174:   if(FALSE == mSmacInitialized)
  002b c60000   [4]             LDA   smacFlags
  002e a502     [2]             BIT   #2
  0030 2604     [3]             BNE   L36 ;abs = 0036
  175:    {
  176:      return gErrorNoValidCondition_c;
  0032 a604     [2]             LDA   #4
  0034 2061     [3]             BRA   L97 ;abs = 0097
  0036          L36:    
  177:    }
  178:  #endif
  179:  
  180:    if(mSmacStateIdle_c != smacState)
  0036 c60000   [4]             LDA   smacState
  0039 2704     [3]             BEQ   L3F ;abs = 003f
  181:    {
  182:      return gErrorBusy_c;
  003b a601     [2]             LDA   #1
  003d 2058     [3]             BRA   L97 ;abs = 0097
  003f          L3F:    
  183:    }
  184:  
  185:    
  186:    u8PhyRes = PhyPlmeRxRequest(pAuxPacket, &smacLastDataRxParams);
  003f 9efe01   [5]             LDHX  1,SP
  0042 89       [2]             PSHX  
  0043 8b       [2]             PSHH  
  0044 450000   [3]             LDHX  @smacLastDataRxParams
  0047 cd0000   [6]             JSR   PhyPlmeRxRequest
  004a a702     [2]             AIS   #2
  187:  
  188:    if(!u8PhyRes)
  004c 4d       [1]             TSTA  
  004d 2646     [3]             BNE   L95 ;abs = 0095
  189:    {
  190:    
  191:      if(u32Timeout)
  004f 95       [2]             TSX   
  0050 e608     [3]             LDA   8,X
  0052 ea07     [3]             ORA   7,X
  0054 ea06     [3]             ORA   6,X
  0056 ea05     [3]             ORA   5,X
  0058 2723     [3]             BEQ   L7D ;abs = 007d
  192:      {
  193:        smacTimeout = u32Timeout; 
  005a 9efe08   [5]             LDHX  8,SP
  005d 960002   [5]             STHX  smacTimeout:2
  0060 9efe06   [5]             LDHX  6,SP
  0063 960000   [5]             STHX  smacTimeout
  194:        SmacSetRxTimeout((zbClock24_t)smacTimeout);
  0066 9ee609   [4]             LDA   9,SP
  0069 87       [2]             PSHA  
  006a 9ee609   [4]             LDA   9,SP
  006d 87       [2]             PSHA  
  006e 89       [2]             PSHX  
  006f 8b       [2]             PSHH  
  0070 ac000000 [8]             CALL  SmacSetRxTimeout
  0074 a704     [2]             AIS   #4
  195:        mSmacTimeoutAsked = TRUE;
  0076 c60000   [4]             LDA   smacFlags
  0079 aa10     [2]             ORA   #16
  196:      }
  007b 2005     [3]             BRA   L82 ;abs = 0082
  007d          L7D:    
  197:      else
  198:      {
  199:        mSmacTimeoutAsked = FALSE;
  007d c60000   [4]             LDA   smacFlags
  0080 a4ef     [2]             AND   #-17
  0082          L82:    
  0082 c70000   [4]             STA   smacFlags
  200:      }
  201:  
  202:      gsRxPacket->rxStatus = rxProcessingReceptionStatus_c;
  0085 9efe0a   [5]             LDHX  10,SP
  0088 a601     [2]             LDA   #1
  008a e701     [3]             STA   1,X
  203:      smacProccesPacketPtr.smacRxPacketPointer  = gsRxPacket;
  008c 960000   [5]             STHX  smacProccesPacketPtr
  204:  
  205:      smacState= mSmacStateReceiving_c; 
  008f 4c       [1]             INCA  
  0090 c70000   [4]             STA   smacState
  206:      return gErrorNoError_c;
  0093 4f       [1]             CLRA  
  0094 65       [3]             SKIP2 L97 ;abs = 0097
  0095          L95:    
  207:    }
  208:    else
  209:    {
  210:      return gErrorNoResourcesAvailable_c;
  0095 a603     [2]             LDA   #3
  0097          L97:    
  211:    }
  212:  }
  0097 a702     [2]             AIS   #2
  0099 8d       [7]             RTC   
  213:  
  214:  /************************************************************************************
  215:  * MLMERXDisableRequest
  216:  * 
  217:  * Returns the radio to idle mode from receive mode.
  218:  *
  219:  ************************************************************************************/
  220:  smacErrors_t MLMERXDisableRequest(void)
  221:  {
  222:  #if(TRUE == smacInitializationValidation_d)
  223:   if(FALSE == mSmacInitialized)
  0000 c60000   [4]             LDA   smacFlags
  0003 a502     [2]             BIT   #2
  0005 2709     [3]             BEQ   L10 ;abs = 0010
  224:    {
  225:      return gErrorNoValidCondition_c;
  226:    }
  227:  #endif
  228:    if((mSmacStateReceiving_c != smacState) && (mSmacStateIdle_c != smacState))
  0007 c60000   [4]             LDA   smacState
  000a 410206   [4]             CBEQA #2,L13 ;abs = 0013
  000d 4d       [1]             TSTA  
  000e 2703     [3]             BEQ   L13 ;abs = 0013
  0010          L10:    
  229:    {
  230:      return gErrorNoValidCondition_c;
  0010 a604     [2]             LDA   #4
  0012 8d       [7]             RTC   
  0013          L13:    
  231:    }
  232:    
  233:    PhyPlmeForceTrxOffRequest();
  0013 cd0000   [6]             JSR   PhyAbort
  234:    mSmacTimeoutAsked = FALSE;
  0016 450000   [3]             LDHX  @smacFlags
  0019 f6       [3]             LDA   ,X
  001a a4ef     [2]             AND   #-17
  001c f7       [2]             STA   ,X
  235:    
  236:    smacState= mSmacStateIdle_c;
  001d 4f       [1]             CLRA  
  001e c70000   [4]             STA   smacState
  237:    return gErrorNoError_c;
  238:  
  239:  }
  0021 8d       [7]             RTC   
  240:   
  241:  
  242:  /************************************************************************************
  243:  * MLMELinkQuality
  244:  * 
  245:  * This  function  returns  an  integer  value  that is the link quality from the last 
  246:  * received packet of the form:  dBm = (-Link Quality/2).
  247:  *
  248:  ************************************************************************************/
  249:  uint8_t MLMELinkQuality(void)
  250:  {
  251:  #if(TRUE == smacInitializationValidation_d)
  252:   if(FALSE == mSmacInitialized)
  0000 c60000   [4]             LDA   smacFlags
  0003 a502     [2]             BIT   #2
  0005 2602     [3]             BNE   L9 ;abs = 0009
  253:    {
  254:      return 0;
  0007 4f       [1]             CLRA  
  0008 8d       [7]             RTC   
  0009          L9:     
  255:    }
  256:  #endif
  257:    return smacLastDataRxParams.linkQuality;
  0009 c60004   [4]             LDA   smacLastDataRxParams:4
  258:  }
  000c 8d       [7]             RTC   
  259:  
  260:  
  261:  
  262:  /***********************************************************************************/
  263:  /******************************** SMAC Radio primitives ****************************/
  264:  /***********************************************************************************/
  265:  
  266:  /************************************************************************************
  267:  * MLMERadioInit
  268:  * 
  269:  * This function initializes the Radio parameters.
  270:  *
  271:  ************************************************************************************/
  272:  smacErrors_t MLMERadioInit(void)
  273:  {
  274:    uint8_t u8PhyRes = 0; 
  275:    
  276:    PhyInit();
  0000 cd0000   [6]             JSR   PhyInit
  277:    
  278:    u8PhyRes =  PhyPlmeSetCurrentChannelRequest((uint8_t)gChannel11_c);
  0003 a60b     [2]             LDA   #11
  0005 cd0000   [6]             JSR   PhyPlmeSetCurrentChannelRequest
  279:    u8PhyRes += PhyPlmeSetPwrLevelRequest(15);
  0008 87       [2]             PSHA  
  0009 a60f     [2]             LDA   #15
  000b cd0000   [6]             JSR   PhyPlmeSetPwrLevelRequest
  000e 95       [2]             TSX   
  000f fb       [3]             ADD   ,X
  280:    
  281:    PhyPpSetCcaThreshold(129); //
  0010 f7       [2]             STA   ,X
  0011 a681     [2]             LDA   #-127
  0013 cd0000   [6]             JSR   PhyPpSetCcaThreshold
  282:    PhyPpSetPromiscuous(TRUE);
  0016 a601     [2]             LDA   #1
  0018 cd0000   [6]             JSR   PhyPpSetPromiscuous
  283:    
  284:    smacCurrentChannel = gChannel11_c;
  001b a60b     [2]             LDA   #11
  001d c70000   [4]             STA   smacCurrentChannel
  285:    smacState= mSmacStateIdle_c;
  0020 4f       [1]             CLRA  
  0021 c70000   [4]             STA   smacState
  286:    smacLastDataRxParams.linkQuality = 0;
  0024 c70004   [4]             STA   smacLastDataRxParams:4
  287:    smacLastDataRxParams.timeStamp = 0;
  0027 8c       [1]             CLRH  
  0028 5f       [1]             CLRX  
  0029 960002   [5]             STHX  smacLastDataRxParams:2
  002c 960000   [5]             STHX  smacLastDataRxParams
  288:    smacEdValue = 0;
  002f c70000   [4]             STA   smacEdValue
  289:    smacClearestChann = gChannelOutOfRange_c; 
  0032 a61b     [2]             LDA   #27
  0034 c70000   [4]             STA   smacClearestChann
  290:    smacFlags.flags.flag0 = gPromiscuousMode_d;
  0037 450000   [3]             LDHX  @smacFlags
  003a f6       [3]             LDA   ,X
  003b a4fe     [2]             AND   #-2
  003d f7       [2]             STA   ,X
  291:    smacFlags.flags.flag1 = 0;
  003e a4fd     [2]             AND   #-3
  0040 f7       [2]             STA   ,X
  292:    smacFlags.flags.flag2 = 0;
  0041 a4fb     [2]             AND   #-5
  0043 f7       [2]             STA   ,X
  293:    smacFlags.flags.flag3 = 0;
  0044 a4f7     [2]             AND   #-9
  0046 f7       [2]             STA   ,X
  294:    smacFlags.flags.flag4 = 0;
  0047 a4ef     [2]             AND   #-17
  0049 f7       [2]             STA   ,X
  295:    smacFlags.flags.flag5 = 0;
  004a a4df     [2]             AND   #-33
  004c f7       [2]             STA   ,X
  296:    smacFlags.flags.flag6 = 0;
  004d a4bf     [2]             AND   #-65
  004f f7       [2]             STA   ,X
  297:    smacFlags.flags.flag7 = 0;
  0050 a47f     [2]             AND   #127
  0052 f7       [2]             STA   ,X
  298:    /* it means:
  299:                mPromiscuousModeEnabled = FALSE;
  300:                mSmacInitialized        = FALSE;
  301:                mSmacTimeoutAsked       = FALSE;
  302:                mSmacPerformingCCAScan  = FALSE;
  303:                mSmacPerformingEDScan   = FALSE;
  304:                mSmacPerformingED       = FALSE;
  305:    */
  306:          
  307:    if(!u8PhyRes)
  0053 88       [3]             PULX  
  0054 5d       [1]             TSTX  
  0055 2607     [3]             BNE   L5E ;abs = 005e
  308:    {
  309:  #if(TRUE == smacInitializationValidation_d)
  310:      mSmacInitialized = TRUE;  
  0057 aa02     [2]             ORA   #2
  0059 c70000   [4]             STA   smacFlags
  311:  #endif
  312:      return gErrorNoError_c;
  005c 4f       [1]             CLRA  
  005d 8d       [7]             RTC   
  005e          L5E:    
  313:    }
  314:    else
  315:    {
  316:      return gErrorNoResourcesAvailable_c;
  005e a603     [2]             LDA   #3
  317:    }
  318:  }
  0060 8d       [7]             RTC   
  319:  
  320:  /************************************************************************************
  321:  * MLMEDozeRequest
  322:  * 
  323:  * Doze request allow the user to put the radio either in Normal Doze Mode (without 
  324:  * CLKO but with automatic wake up) or Acoma Doze Mode (with CLKout, but without 
  325:  * timeout). 
  326:  * This primitive is used just on the MC1320x and MC1321x platforms, for 
  327:  * the MC1323x radio it is just an stub.
  328:  *
  329:  ************************************************************************************/
  330:  smacErrors_t MLMEDozeRequest
  331:  (
  332:  uint32_t u32Timeout //IN: Is the automatic wake up time for this mode.
  333:  )
  334:  {
  335:  #if defined (gMcs08Gt60Platform_d) || defined (gMcs08qe128Platform_d)
  336:  	uint8_t u8Status = 0;	
  337:  	if(mSmacStateIdle_c != smacState)
  0000 c60000   [4]             LDA   smacState
  0003 2703     [3]             BEQ   L8 ;abs = 0008
  338:  		{
  339:  		      return gErrorBusy_c; /*the radio is busy in other activity as transmitting  
  0005 a601     [2]             LDA   #1
  0007 8d       [7]             RTC   
  0008          L8:     
  340:  			                        or receiving data. Or performing a channel scan*/
  341:  		}
  342:  		
  343:  			
  344:  			u8Status = PhyPlmeDozeRequest(u32Timeout);
  0008 9efe06   [5]             LDHX  6,SP
  000b 89       [2]             PSHX  
  000c 8b       [2]             PSHH  
  000d 9efe06   [5]             LDHX  6,SP
  0010 89       [2]             PSHX  
  0011 8b       [2]             PSHH  
  0012 cd0000   [6]             JSR   PhyPlmeDozeRequest
  0015 a704     [2]             AIS   #4
  345:  		    if (u8Status==gErrorNoError_c){
  0017 4d       [1]             TSTA  
  0018 2605     [3]             BNE   L1F ;abs = 001f
  346:  		    	smacState = mSmacStateDoze_c;
  001a a606     [2]             LDA   #6
  001c c70000   [4]             STA   smacState
  001f          L1F:    
  347:  		    return gErrorNoError_c; /*The radio has been set in Doze Mode*/;
  348:  		    }
  349:  #endif
  350:  #if defined gMc1323xPlatform_d 
  351:  		    return gErrorNoError_c; 
  352:  	#else
  353:  		    return gErrorNoError_c;
  001f 4f       [1]             CLRA  
  354:  #endif
  355:  }
  0020 8d       [7]             RTC   
  356:  
  357:  /************************************************************************************
  358:  * MLMEEnergyDetect
  359:  * 
  360:  * This call starts an energy detect(ED) cycle, it returns the energy value (-power/2)
  361:  * via the returned argument. For example, if the Energy Detect returns 80 then the 
  362:  * interpreted value is -80/2 or -40 dBm.
  363:  *
  364:  ************************************************************************************/
  365:  uint8_t MLMEEnergyDetect(void)
  366:  {
  367:  #if(TRUE == smacInitializationValidation_d)
  368:    if(FALSE == mSmacInitialized)
  0000 c60000   [4]             LDA   smacFlags
  0003 a502     [2]             BIT   #2
  0005 2717     [3]             BEQ   L1E ;abs = 001e
  369:    {
  370:      return 0xFF;
  371:    }
  372:  #endif
  373:  
  374:    if(mSmacStateIdle_c != smacState)
  0007 ce0000   [4]             LDX   smacState
  000a 2703     [3]             BEQ   LF ;abs = 000f
  375:    {
  376:      return gErrorBusy_c;
  000c a601     [2]             LDA   #1
  000e 8d       [7]             RTC   
  000f          LF:     
  377:    }
  378:    mSmacPerformingED = TRUE;
  000f aa80     [2]             ORA   #-128
  0011 c70000   [4]             STA   smacFlags
  379:    smacEdValue = 0;
  0014 4f       [1]             CLRA  
  0015 c70000   [4]             STA   smacEdValue
  380:    
  381:    if(PhyPlmeEdRequest())
  0018 cd0000   [6]             JSR   PhyPlmeCcaEdRequest
  001b 4d       [1]             TSTA  
  001c 2703     [3]             BEQ   L21 ;abs = 0021
  001e          L1E:    
  382:    {
  383:      return 0xFF;
  001e a6ff     [2]             LDA   #-1
  0020 8d       [7]             RTC   
  0021          L21:    
  384:    }
  385:    
  386:    while(TRUE == mSmacPerformingED)
  0021 c60000   [4]             LDA   smacFlags
  0024 2bfb     [3]             BMI   L21 ;abs = 0021
  387:    {
  388:      /*Add a method to avoid blocking the system*/
  389:    }
  390:    
  391:    return smacEdValue;
  0026 c60000   [4]             LDA   smacEdValue
  392:  }
  0029 8d       [7]             RTC   
  393:  
  394:  /************************************************************************************
  395:  * MLMEFEGainAdjust
  396:  * 
  397:  * This is a compensator for the energy detection and AGC. In case users need to 
  398:  * calibrate the readings due to a specific application like an external low noise 
  399:  * amplifier, this is where users can set the offset.
  400:  * This primitive is used just on the MC1320x and MC1321x platforms, for the 
  401:  * MC1323x radio it is just an stub.
  402:  *
  403:  ************************************************************************************/
  404:  smacErrors_t MLMEFEGainAdjust
  405:  (
  406:  uint8_t u8GainValue //IN: 8 bit value for the gain adjust.
  407:  )
  408:  {
  409:    if(mSmacStateIdle_c != smacState)
  0000 ce0000   [4]             LDX   smacState
  0003 2703     [3]             BEQ   L8 ;abs = 0008
  410:    {
  411:      return gErrorBusy_c;
  0005 a601     [2]             LDA   #1
  0007 8d       [7]             RTC   
  0008          L8:     
  412:    }
  413:    PhyAdjustCcaOffsetCmp(u8GainValue);
  0008 cd0000   [6]             JSR   PhyAdjustCcaOffsetCmp
  414:    
  415:    return gErrorNoError_c;
  000b 4f       [1]             CLRA  
  416:  }
  000c 8d       [7]             RTC   
  417:  
  418:  /************************************************************************************
  419:  * MLMESetChannelRequest
  420:  * 
  421:  * This function sets the frequency on which the radio will transmit or receive on.
  422:  *
  423:  ************************************************************************************/
  424:  smacErrors_t MLMESetChannelRequest
  425:  (
  426:  channels_t newChannel //IN: Enumeration value that represents the requested channel. 
  427:  )
  428:  {
  0000 87       [2]             PSHA  
  429:   uint8_t u8PhyRes;
  430:  
  431:  #if(TRUE == smacParametersValidation_d)
  432:    if((gChannel11_c > newChannel) || (gChannel26_c < newChannel))
  0001 a10b     [2]             CMP   #11
  0003 2504     [3]             BCS   L9 ;abs = 0009
  0005 a11a     [2]             CMP   #26
  0007 2304     [3]             BLS   LD ;abs = 000d
  0009          L9:     
  433:    {
  434:      return gErrorOutOfRange_c;
  0009 a602     [2]             LDA   #2
  435:    }
  436:  #endif
  437:  
  438:  #if(TRUE == smacInitializationValidation_d)
  439:    if(FALSE == mSmacInitialized)
  440:    {
  441:      return gErrorNoValidCondition_c;
  442:    }
  443:  #endif
  444:  
  445:    if((mSmacStateIdle_c != smacState) && (mSmacStatePerformingTest_c != smacState))
  446:    {
  447:      return gErrorBusy_c;
  448:    }
  449:    
  450:    u8PhyRes = PhyPlmeSetCurrentChannelRequest((uint8_t)newChannel);
  451:    
  452:    if(!u8PhyRes)
  453:    {
  454:      smacCurrentChannel = newChannel;
  455:      return gErrorNoError_c;
  456:    }
  457:    else 
  458:    {
  459:      return gErrorNoResourcesAvailable_c;
  460:    }
  461:  }
  000b 8a       [3]             PULH  
  000c 8d       [7]             RTC   
  000d          LD:     
  000d c60000   [4]             LDA   smacFlags
  0010 a502     [2]             BIT   #2
  0012 2604     [3]             BNE   L18 ;abs = 0018
  0014 a604     [2]             LDA   #4
  0016 8a       [3]             PULH  
  0017 8d       [7]             RTC   
  0018          L18:    
  0018 c60000   [4]             LDA   smacState
  001b 2707     [3]             BEQ   L24 ;abs = 0024
  001d 410404   [4]             CBEQA #4,L24 ;abs = 0024
  0020 a601     [2]             LDA   #1
  0022 8a       [3]             PULH  
  0023 8d       [7]             RTC   
  0024          L24:    
  0024 95       [2]             TSX   
  0025 f6       [3]             LDA   ,X
  0026 cd0000   [6]             JSR   PhyPlmeSetCurrentChannelRequest
  0029 4d       [1]             TSTA  
  002a 2608     [3]             BNE   L34 ;abs = 0034
  002c 95       [2]             TSX   
  002d f6       [3]             LDA   ,X
  002e c70000   [4]             STA   smacCurrentChannel
  0031 4f       [1]             CLRA  
  0032 8a       [3]             PULH  
  0033 8d       [7]             RTC   
  0034          L34:    
  0034 a603     [2]             LDA   #3
  0036 8a       [3]             PULH  
  0037 8d       [7]             RTC   
  462:  
  463:  /************************************************************************************
  464:  * MLMEGetChannelRequest
  465:  * 
  466:  * This function returns the current channel, if an error is detected it returns 
  467:  * gChannelOutOfRange_c.
  468:  *
  469:  ************************************************************************************/
  470:  channels_t MLMEGetChannelRequest(void)
  471:  {
  472:  #if(TRUE == smacInitializationValidation_d)
  473:    if(FALSE == mSmacInitialized)
  0000 c60000   [4]             LDA   smacFlags
  0003 a502     [2]             BIT   #2
  0005 270b     [3]             BEQ   L12 ;abs = 0012
  474:    {
  475:      return gChannelOutOfRange_c;
  476:    }
  477:  #endif
  478:    if((gChannel11_c > smacCurrentChannel) || (gChannel26_c < smacCurrentChannel))
  0007 c60000   [4]             LDA   smacCurrentChannel
  000a a10b     [2]             CMP   #11
  000c 2504     [3]             BCS   L12 ;abs = 0012
  000e a11a     [2]             CMP   #26
  0010 2302     [3]             BLS   L14 ;abs = 0014
  0012          L12:    
  479:    {
  480:      return gChannelOutOfRange_c;
  0012 a61b     [2]             LDA   #27
  0014          L14:    
  481:    }
  482:    else
  483:    {
  484:      return smacCurrentChannel;
  485:    }
  486:  }
  0014 8d       [7]             RTC   
  487:  
  488:  /************************************************************************************
  489:  * MLMEHibernateRequest
  490:  * 
  491:  * This call places the radio into Hibernate mode. 
  492:  * On the MC1320x and MC1321x platforms it sets the radio to hibernate 
  493:  * operation mode, for the MC1323x radio it disables the clock source for the 
  494:  * tranceiver module.
  495:  *
  496:  ************************************************************************************/
  497:  smacErrors_t MLMEHibernateRequest(void)
  498:  {
  499:   #if defined(gMc1323xPlatform_d) 
  500:    return gErrorNoError_c;
  501:   #else
  502:   
  503:   #if defined(gMcs08Gt60Platform_d) || defined(gMcs08qe128Platform_d) 
  504:  
  505:   #if(TRUE == smacInitializationValidation_d)
  506:    if(FALSE == mSmacInitialized)
  0000 c60000   [4]             LDA   smacFlags
  0003 a502     [2]             BIT   #2
  0005 2603     [3]             BNE   LA ;abs = 000a
  507:    {
  508:      return gErrorNoValidCondition_c;
  0007 a604     [2]             LDA   #4
  0009 8d       [7]             RTC   
  000a          LA:     
  509:    }
  510:   #endif
  511:  
  512:    if(mSmacStateIdle_c != smacState)
  000a c60000   [4]             LDA   smacState
  000d 2703     [3]             BEQ   L12 ;abs = 0012
  513:    {
  514:      return gErrorBusy_c;
  000f a601     [2]             LDA   #1
  0011 8d       [7]             RTC   
  0012          L12:    
  515:    }
  516:  
  517:    PhyHibernateRequest();
  0012 cd0000   [6]             JSR   PhyHibernateRequest
  518:    
  519:    smacState = mSmacStateHibernate_c;
  0015 a605     [2]             LDA   #5
  0017 c70000   [4]             STA   smacState
  520:    
  521:    return gErrorNoError_c;
  001a 4f       [1]             CLRA  
  522:    
  523:   #endif
  524:      
  525:   #endif
  526:  }
  001b 8d       [7]             RTC   
  527:  
  528:  
  529:  /************************************************************************************
  530:  * MLMEPAOutputAdjust
  531:  * 
  532:  * This function adjusts the output power of the transmitter. 
  533:  *
  534:  ************************************************************************************/
  535:  smacErrors_t MLMEPAOutputAdjust
  536:  (
  537:  uint8_t u8PaValue //IN: Value for the output power desired. Values 0-15 are required.
  538:  )
  539:  {    
  0000 87       [2]             PSHA  
  540:    uint8_t u8PhyRes;
  541:  
  542:  #if(TRUE == smacParametersValidation_d)
  543:    if(gMaxOutputPower_c < u8PaValue)
  0001 a10f     [2]             CMP   #15
  0003 2304     [3]             BLS   L9 ;abs = 0009
  544:    {
  545:      return gErrorOutOfRange_c;
  0005 a602     [2]             LDA   #2
  546:    }
  547:  #endif
  548:  
  549:  #if(TRUE == smacInitializationValidation_d)
  550:    if(FALSE == mSmacInitialized)
  551:    {
  552:      return gErrorNoValidCondition_c;
  553:    }
  554:  #endif
  555:  
  556:    if((mSmacStateIdle_c != smacState) && (mSmacStatePerformingTest_c != smacState))
  557:    {
  558:      return gErrorBusy_c;
  559:    }
  560:    
  561:    u8PhyRes = PhyPlmeSetPwrLevelRequest(u8PaValue);
  562:    
  563:    if(!u8PhyRes)
  564:    {
  565:      return gErrorNoError_c;
  566:    }
  567:    else 
  568:    {
  569:      return gErrorNoResourcesAvailable_c;
  570:    }
  571:  }
  0007 8a       [3]             PULH  
  0008 8d       [7]             RTC   
  0009          L9:     
  0009 c60000   [4]             LDA   smacFlags
  000c a502     [2]             BIT   #2
  000e 2604     [3]             BNE   L14 ;abs = 0014
  0010 a604     [2]             LDA   #4
  0012 8a       [3]             PULH  
  0013 8d       [7]             RTC   
  0014          L14:    
  0014 c60000   [4]             LDA   smacState
  0017 2707     [3]             BEQ   L20 ;abs = 0020
  0019 410404   [4]             CBEQA #4,L20 ;abs = 0020
  001c a601     [2]             LDA   #1
  001e 8a       [3]             PULH  
  001f 8d       [7]             RTC   
  0020          L20:    
  0020 95       [2]             TSX   
  0021 f6       [3]             LDA   ,X
  0022 cd0000   [6]             JSR   PhyPlmeSetPwrLevelRequest
  0025 4d       [1]             TSTA  
  0026 2702     [3]             BEQ   L2A ;abs = 002a
  0028 a603     [2]             LDA   #3
  002a          L2A:    
  002a 8a       [3]             PULH  
  002b 8d       [7]             RTC   
  572:  
  573:  /************************************************************************************
  574:  * MLMEPHYXtalAdjust
  575:  * 
  576:  * This function is used to adjust the radio reference clock by a trim value.
  577:  *
  578:  ************************************************************************************/
  579:  smacErrors_t MLMEXtalAdjust
  580:  (
  581:  uint8_t u8ReqValue //IN: value representing the trim value to the oscillator.
  582:  )
  583:  {
  584:    if((mSmacStateIdle_c != smacState) && (mSmacStatePerformingTest_c != smacState))
  0000 ce0000   [4]             LDX   smacState
  0003 2706     [3]             BEQ   LB ;abs = 000b
  0005 510403   [4]             CBEQX #4,LB ;abs = 000b
  585:    {
  586:      return gErrorBusy_c;
  0008 a601     [2]             LDA   #1
  000a 8d       [7]             RTC   
  000b          LB:     
  587:    }
  588:    
  589:    PhyXtalAdjust(u8ReqValue);
  000b cd0000   [6]             JSR   PhyXtalAdjust
  590:    
  591:    return gErrorNoError_c;
  000e 4f       [1]             CLRA  
  592:  }
  000f 8d       [7]             RTC   
  593:  
  594:  /************************************************************************************
  595:  * MLMESoftReset
  596:  * 
  597:  * This function performs a software reset on the radio,  PHY and SMAC state machines.
  598:  *
  599:  ************************************************************************************/
  600:  smacErrors_t MLMESoftReset(void)
  601:  {
  602:    PhyAbort();
  0000 cd0000   [6]             JSR   PhyAbort
  603:    return MLMERadioInit();
  0003 ac000000 [8]             CALL  MLMERadioInit
  604:  }
  0007 8d       [7]             RTC   
  605:  
  606:  /************************************************************************************
  607:  * MLMESetClockRate
  608:  * 
  609:  * This function is called to set the desired clock out from radio.
  610:  * This primitive is used just on the MC1320x and MC1321x platforms, for the 
  611:  * MC1323x radio it is just an stub.
  612:  *
  613:  ************************************************************************************/
  614:  smacErrors_t MLMESetClockRate
  615:  (
  616:  clkoFrequency_t Freq  //IN: Enumeration value that represents radio clock out 
  617:                        //    frequency (CLKO). 
  618:  )
  619:  {
  620:    return PhyPlmeSetClockOutRate(Freq);
  0000 cd0000   [6]             JSR   PhyPlmeSetClockOutRate
  621:  }
  0003 8d       [7]             RTC   
  622:  
  623:  
  624:  
  625:  /************************************************************************************
  626:  * MLMESetTmrPrescale
  627:  * 
  628:  * This function changes the rate at which the radio timers operate.
  629:  *
  630:  ************************************************************************************/
  631:  smacErrors_t MLMESetTmrPrescale
  632:  (
  633:  timerTimeBase_t TimeBase //IN: enumeration value that represents that represents  
  634:                           //    timer prescale or time base.
  635:  )
  636:  {
  637:  #if(TRUE == smacParametersValidation_d)
  638:    if((gTimeBase500kHz_c > TimeBase) || (gTimeBase16p625kHz_c < TimeBase))
  0000 a102     [2]             CMP   #2
  0002 2504     [3]             BCS   L8 ;abs = 0008
  0004 a107     [2]             CMP   #7
  0006 2303     [3]             BLS   LB ;abs = 000b
  0008          L8:     
  639:    {
  640:      return gErrorOutOfRange_c;
  0008 a602     [2]             LDA   #2
  000a 8d       [7]             RTC   
  000b          LB:     
  641:    }
  642:  #endif
  643:  
  644:  #if(TRUE == smacInitializationValidation_d)
  645:    if(FALSE == mSmacInitialized)
  000b 97       [1]             TAX   
  000c c60000   [4]             LDA   smacFlags
  000f a502     [2]             BIT   #2
  0011 2603     [3]             BNE   L16 ;abs = 0016
  646:    {
  647:      return gErrorNoValidCondition_c;
  0013 a604     [2]             LDA   #4
  0015 8d       [7]             RTC   
  0016          L16:    
  648:    }
  649:  #endif
  650:  
  651:    PhySetRadioTimerPrescaler((uint8_t)TimeBase);
  0016 9f       [1]             TXA   
  0017 cd0000   [6]             JSR   PhySetRadioTimerPrescaler
  652:    return gErrorNoError_c;
  001a 4f       [1]             CLRA  
  653:  }
  001b 8d       [7]             RTC   
  654:  
  655:  /************************************************************************************
  656:  * MLMEWakeRequest
  657:  * 
  658:  * This primitive brings the radio out of low power mode.
  659:  *
  660:  ************************************************************************************/
  661:  smacErrors_t MLMEWakeRequest(void)
  662:  {
  663:   #if defined(gMc1323xPlatform_d) 
  664:    return gErrorNoError_c; 
  665:  #else
  666:     #if defined(gMcs08Gt60Platform_d)  || defined (gMcs08qe128Platform_d)
  667:  
  668:   #if(TRUE == smacInitializationValidation_d)
  669:    if(FALSE == mSmacInitialized)
  0000 c60000   [4]             LDA   smacFlags
  0003 a502     [2]             BIT   #2
  0005 2711     [3]             BEQ   L18 ;abs = 0018
  670:    {
  671:      return gErrorNoValidCondition_c;
  672:    }
  673:   #endif
  674:  
  675:    if(mSmacStateIdle_c == smacState)
  0007 c60000   [4]             LDA   smacState
  000a 270c     [3]             BEQ   L18 ;abs = 0018
  676:    {
  677:      return gErrorNoValidCondition_c;
  678:    }
  679:  
  680:    if (smacState == mSmacStateDoze_c || smacState == mSmacStateHibernate_c)
  000c 410604   [4]             CBEQA #6,L13 ;abs = 0013
  000f a105     [2]             CMP   #5
  0011 2605     [3]             BNE   L18 ;abs = 0018
  0013          L13:    
  681:    {
  682:        PhyWakeRequest();
  0013 cd0000   [6]             JSR   PhyWakeRequest
  683:        return gErrorNoError_c;
  0016 4f       [1]             CLRA  
  0017 8d       [7]             RTC   
  0018          L18:    
  684:    }
  685:  
  686:    return gErrorNoValidCondition_c;
  0018 a604     [2]             LDA   #4
  687:     #endif 
  688:   #endif
  689:  
  690:  }
  001a 8d       [7]             RTC   
  691:  
  692:  /************************************************************************************
  693:  * XCVRContReset
  694:  * 
  695:  * This function asserts the reset line of the transceiver, shutting it down to its 
  696:  * lowest power mode.
  697:  * This primitive is used just on the MC1320x and MC1321x platforms, for the
  698:  * MC1323x radio it is just an stub.
  699:  *
  700:  ************************************************************************************/
  701:  void XCVRContReset(void)
  702:  {
  703:   #if defined(gMcs08Gt60Platform_d) 
  704:    PhyXCVRContReset(); 
  705:   #endif 
  706:  }
  0000 8d       [7]             RTC   
  707:  
  708:  /************************************************************************************
  709:  * XCVRRestart
  710:  * 
  711:  * This function deasserts the reset line, thus it power the transceiver up.
  712:  * This primitive is used just on the MC1320x and MC1321x platforms, for the
  713:  * MC1323x radio it is just an stub.
  714:  *
  715:  ************************************************************************************/
  716:  void XCVRRestart(void)
  717:  {
  718:   #if defined(gMcs08Gt60Platform_d) 
  719:    PhyXCVRRestart(); 
  720:   #endif 
  721:  }
  0000 8d       [7]             RTC   
  722:  
  723:  
  724:  /***********************************************************************************/
  725:  /***************************** SMAC management primitives **************************/
  726:  /***********************************************************************************/
  727:  
  728:  /************************************************************************************
  729:  * MLMEGetRficVersion
  730:  * 
  731:  * This function is used to read the version number of different hardware and software 
  732:  * modules inside the SMAC platform.
  733:  *
  734:  ************************************************************************************/
  735:  smacErrors_t MLMEGetRficVersion
  736:  (
  737:  versionedEntity_t Entity, //IN: The module for which the version is required.  
  738:  uint8_t *Buffer           //OUT: A pointer to the buffer where the version will be 
  739:                            //     written.
  740:  )
  741:  {
  0000 87       [2]             PSHA  
  0001 89       [2]             PSHX  
  0002 8b       [2]             PSHH  
  742:    uint8_t u8i;
  743:  
  744:  #if(TRUE == smacParametersValidation_d)
  745:    if(gMaxVersionedEntity_c <= Entity){
  0003 a102     [2]             CMP   #2
  0005 2504     [3]             BCS   LB ;abs = 000b
  746:      return gErrorOutOfRange_c;
  0007 a602     [2]             LDA   #2
  0009 2037     [3]             BRA   L42 ;abs = 0042
  000b          LB:     
  747:    }
  748:  #endif
  749:  
  750:  #if(TRUE == smacInitializationValidation_d)
  751:    if(FALSE == mSmacInitialized)
  000b c60000   [4]             LDA   smacFlags
  000e a502     [2]             BIT   #2
  0010 2604     [3]             BNE   L16 ;abs = 0016
  752:    {
  753:      return gErrorNoValidCondition_c;
  0012 a604     [2]             LDA   #4
  0014 202c     [3]             BRA   L42 ;abs = 0042
  0016          L16:    
  754:    }
  755:  #endif
  756:  
  757:    if(mSmacStateIdle_c != smacState)
  0016 c60000   [4]             LDA   smacState
  0019 2704     [3]             BEQ   L1F ;abs = 001f
  758:    {
  759:      return gErrorBusy_c;
  001b a601     [2]             LDA   #1
  001d 2023     [3]             BRA   L42 ;abs = 0042
  001f          L1F:    
  760:    }
  761:  
  762:    if(gSwSmacVersion_c == Entity)
  001f 9e6d03   [5]             TST   3,SP
  0022 261a     [3]             BNE   L3E ;abs = 003e
  763:    {
  764:      for(u8i=0; u8i < gSwSmacVersionLength_c; u8i++)
  0024 5f       [1]             CLRX  
  0025          L25:    
  765:      {
  766:        *Buffer++ = au8SmacVersion[u8i];
  0025 8c       [1]             CLRH  
  0026 d60000   [4]             LDA   @au8SmacVersion,X
  0029 89       [2]             PSHX  
  002a 9efe02   [5]             LDHX  2,SP
  002d f7       [2]             STA   ,X
  002e 95       [2]             TSX   
  002f 6c02     [5]             INC   2,X
  0031 2602     [3]             BNE   L35 ;abs = 0035
  0033 6c01     [5]             INC   1,X
  0035          L35:    
  0035 86       [3]             PULA  
  0036 4c       [1]             INCA  
  0037 a107     [2]             CMP   #7
  0039 97       [1]             TAX   
  003a 2405     [3]             BCC   L41 ;abs = 0041
  003c 20e7     [3]             BRA   L25 ;abs = 0025
  003e          L3E:    
  767:      }
  768:    }
  769:    else
  770:    {
  771:      PhyGetRfIcVersion(Buffer);    
  003e cd0000   [6]             JSR   PhyGetRfIcVersion
  0041          L41:    
  772:    }
  773:  
  774:    return gErrorNoError_c;
  0041 4f       [1]             CLRA  
  0042          L42:    
  775:  }
  0042 a703     [2]             AIS   #3
  0044 8d       [7]             RTC   
  776:  
  777:  /************************************************************************************
  778:  * MLMESetPromiscuousMode
  779:  * 
  780:  * SMAC appends 0xFF7E as the first two bytes of the packet to identify its own 
  781:  * packets from other packets in the same PHY layer. When promiscuous mode is off 
  782:  * SMAC filters the received packets and just allows those beginning with 0xFF7E; 
  783:  * when promiscuous mode is on SMAC let pass all the messages beginning or not with
  784:  * 0xFF7E. MLMESetPromiscuousMode allows setting or clearing the promiscuous mode. 
  785:  *
  786:  ************************************************************************************/
  787:  void MLMESetPromiscuousMode
  788:  (
  789:  bool_t isPromiscousMode //IN: This is a boolean value that indicates if the promiscuous 
  790:                          //    mode is on (TRUE) or off (FALSE).
  791:  )
  792:  {
  793:     mPromiscuousModeEnabled = isPromiscousMode;
  0000 a501     [2]             BIT   #1
  0002 2607     [3]             BNE   LB ;abs = 000b
  0004 c60000   [4]             LDA   smacFlags
  0007 a4fe     [2]             AND   #-2
  0009 2005     [3]             BRA   L10 ;abs = 0010
  000b          LB:     
  000b c60000   [4]             LDA   smacFlags
  000e aa01     [2]             ORA   #1
  0010          L10:    
  0010 c70000   [4]             STA   smacFlags
  794:  }
  0013 8d       [7]             RTC   
  795:  
  796:  /************************************************************************************
  797:  * MLMEGetPromiscuousMode
  798:  * 
  799:  * This function returns the current state of promiscuous mode.
  800:  *
  801:  ************************************************************************************/
  802:  bool_t MLMEGetPromiscuousMode(void)
  803:  {
  804:    return mPromiscuousModeEnabled;
  0000 c60000   [4]             LDA   smacFlags
  0003 a401     [2]             AND   #1
  805:  }
  0005 8d       [7]             RTC   
  806:  
  807:  /************************************************************************************
  808:  * MLMEScanRequest
  809:  * 
  810:  * This function scans the different channels using one out of two techniques and 
  811:  * returns the amount of energy in all of the channels.
  812:  *
  813:  ************************************************************************************/
  814:  smacErrors_t MLMEScanRequest
  815:  (
  816:  uint16_t u16ChannelsToScan, //IN: Bitmap of the Channels to be scanned.
  817:  scanModes_t ScanMode,       //IN: Technique to be used CCA or ED.
  818:  uint8_t *pu8ChannelScan     //OUT: The buffer where the values of the scan will be 
  819:                              //     returned. 
  820:  )
  821:  {
  0000 87       [2]             PSHA  
  0001 89       [2]             PSHX  
  0002 8b       [2]             PSHH  
  822:  
  823:    smacErrors_t scanRes;
  824:  
  825:  #if(TRUE == smacParametersValidation_d)
  826:    if((0 == u16ChannelsToScan) || (gMaxScanMode_c <= ScanMode) || (NULL == pu8ChannelScan))
  0003 9efe07   [5]             LDHX  7,SP
  0006 270c     [3]             BEQ   L14 ;abs = 0014
  0008 a102     [2]             CMP   #2
  000a 2408     [3]             BCC   L14 ;abs = 0014
  000c 9efe01   [5]             LDHX  1,SP
  000f 650000   [3]             CPHX  #0
  0012 2604     [3]             BNE   L18 ;abs = 0018
  0014          L14:    
  827:    {
  828:      return gErrorOutOfRange_c;
  0014 a602     [2]             LDA   #2
  0016 205d     [3]             BRA   L75 ;abs = 0075
  0018          L18:    
  829:    }
  830:  #endif
  831:  
  832:  #if(TRUE == smacInitializationValidation_d)
  833:    if(FALSE == mSmacInitialized)
  0018 c60000   [4]             LDA   smacFlags
  001b a502     [2]             BIT   #2
  001d 2604     [3]             BNE   L23 ;abs = 0023
  834:    {
  835:      return gErrorNoValidCondition_c;
  001f a604     [2]             LDA   #4
  0021 2052     [3]             BRA   L75 ;abs = 0075
  0023          L23:    
  836:    }
  837:  #endif
  838:  
  839:    if(mSmacStateIdle_c != smacState)
  0023 c60000   [4]             LDA   smacState
  0026 2704     [3]             BEQ   L2C ;abs = 002c
  840:    {
  841:      return gErrorBusy_c;
  0028 a601     [2]             LDA   #1
  002a 2049     [3]             BRA   L75 ;abs = 0075
  002c          L2C:    
  842:    }
  843:    smacChannelsBeingScanned = u16ChannelsToScan;
  002c 9efe07   [5]             LDHX  7,SP
  002f 960000   [5]             STHX  smacChannelsBeingScanned
  844:    smacScanCurrentChannel   = gChannel11_c;
  0032 a60b     [2]             LDA   #11
  0034 c70000   [4]             STA   smacScanCurrentChannel
  845:    smacClearestChann        = gChannel11_c;
  0037 c70000   [4]             STA   smacClearestChann
  846:    smacProccesPacketPtr.smacScanResultsPointer = pu8ChannelScan;
  003a 9efe01   [5]             LDHX  1,SP
  003d 960000   [5]             STHX  smacProccesPacketPtr
  847:    smacEdValue              = 0xFF;
  0040 a6ff     [2]             LDA   #-1
  0042 c70000   [4]             STA   smacEdValue
  848:    
  849:    if(gScanModeED_c == ScanMode)
  0045 95       [2]             TSX   
  0046 e602     [3]             LDA   2,X
  0048 4b07     [4]             DBNZA L51 ;abs = 0051
  850:    {
  851:      mSmacPerformingEDScan = TRUE;
  004a c60000   [4]             LDA   smacFlags
  004d aa40     [2]             ORA   #64
  852:    }
  004f 2005     [3]             BRA   L56 ;abs = 0056
  0051          L51:    
  853:    else
  854:    {
  855:      mSmacPerformingCCAScan = TRUE;
  0051 c60000   [4]             LDA   smacFlags
  0054 aa20     [2]             ORA   #32
  0056          L56:    
  0056 c70000   [4]             STA   smacFlags
  856:    }
  857:  
  858:    smacState = mSmacStateScanningChannels_c; 
  0059 a603     [2]             LDA   #3
  005b c70000   [4]             STA   smacState
  859:    scanRes = SmacScanTheNextChannel();
  005e ac000000 [8]             CALL  SmacScanTheNextChannel
  860:    
  861:    if(scanRes)
  0062 4d       [1]             TSTA  
  0063 2710     [3]             BEQ   L75 ;abs = 0075
  862:    {
  863:      smacState = mSmacStateIdle_c; 
  0065 5f       [1]             CLRX  
  0066 cf0000   [4]             STX   smacState
  864:      mSmacPerformingEDScan  = FALSE;
  0069 87       [2]             PSHA  
  006a 450000   [3]             LDHX  @smacFlags
  006d f6       [3]             LDA   ,X
  006e a4bf     [2]             AND   #-65
  0070 f7       [2]             STA   ,X
  865:      mSmacPerformingCCAScan = FALSE;
  0071 a4df     [2]             AND   #-33
  0073 f7       [2]             STA   ,X
  0074 86       [3]             PULA  
  0075          L75:    
  866:    }
  867:    
  868:    return scanRes;
  869:  }
  0075 a703     [2]             AIS   #3
  0077 8d       [7]             RTC   
  870:  
  871:  /************************************************************************************
  872:  * MLMETestMode
  873:  * 
  874:  * By employing this function, users can execute a test of the radio. Test mode 
  875:  * implements the following:
  876:  *   -PRBS9 Mode, 
  877:  *   -Force_idle, 
  878:  *   -Continuos RX, 
  879:  *   -Continuos TX without modulation, 
  880:  *   -Continuos TX with modulation.
  881:  *
  882:  ************************************************************************************/
  883:  smacErrors_t MLMETestMode
  884:  (
  885:  smacTestMode_t  mode  //IN: The test mode to start.
  886:  )
  887:  {
  0000 87       [2]             PSHA  
  888:    uint8_t u8PhyRes = 0; 
  889:    
  890:  
  891:  #if(TRUE == smacParametersValidation_d)
  892:    if(gMaxTestMode_c <= mode)
  0001 a105     [2]             CMP   #5
  0003 2504     [3]             BCS   L9 ;abs = 0009
  893:    {
  894:      return gErrorOutOfRange_c;
  0005 a602     [2]             LDA   #2
  895:    }
  896:  #endif
  897:  
  898:  #if(TRUE == smacInitializationValidation_d)
  899:    if(FALSE == mSmacInitialized)
  900:    {
  901:      return gErrorNoValidCondition_c;
  902:    }
  903:  #endif
  904:    
  905:    if((mSmacStateIdle_c != smacState) && (mSmacStatePerformingTest_c != smacState))
  906:    {
  907:      return gErrorBusy_c;
  908:    }
  909:  
  910:    pTestPacket = (phyPacket_t*)&u8TestBuffer;
  911:    
  912:    smacState = mSmacStatePerformingTest_c;
  913:    PhyDisableContinuousTxRxMode();
  914:    PhyDisableTxNoModulation();
  915:    PhyAbort();
  916:    
  917:     
  918:    if(gTestModeForceIdle_c == mode){
  919:      mSmacPerformingPRBS9 = FALSE;
  920:      smacState = mSmacStateIdle_c;
  921:    }
  922:     
  923:    else if(gTestModeContinuousTxModulated_c == mode){
  924:      PhyDisableTxNoModulation();
  925:      PhyEnableContinuousTxRxMode();
  926:      /*Just begin a dummy Tx to start the radio Test mode*/
  927:      (void)PhyPdDataRequest(pTestPacket, gDataReq_NoAck_NoCca_Unslotted_c, NULL);
  928:    } 
  929:    
  930:    else if(gTestModeContinuousTxUnmodulated_c == mode){
  931:      PhyEnableContinuousTxRxMode();
  932:      PhyEnableTxNoModulation();
  933:      /*Just begin a dummy Tx to start the radio Test mode*/
  934:      (void)PhyPdDataRequest(pTestPacket, gDataReq_NoAck_NoCca_Unslotted_c, NULL);
  935:    } 
  936:    
  937:    else if(gTestModeContinuousRx_c == mode){
  938:      PhyDisableTxNoModulation();
  939:      PhyEnableContinuousTxRxMode();
  940:      (void)PhyPlmeRxRequest(pTestPacket,&smacLastDataRxParams);
  941:    }
  942:  
  943:    else if(gTestModePRBS9_c == mode){
  944:      mSmacPerformingPRBS9 = TRUE;
  945:      (void)PhyPdDataRequest(pTestPacket, gDataReq_NoAck_NoCca_Unslotted_c, NULL);
  946:    }
  947:    return gErrorNoError_c;
  948:  }
  0007 8a       [3]             PULH  
  0008 8d       [7]             RTC   
  0009          L9:     
  0009 c60000   [4]             LDA   smacFlags
  000c a502     [2]             BIT   #2
  000e 2604     [3]             BNE   L14 ;abs = 0014
  0010 a604     [2]             LDA   #4
  0012 8a       [3]             PULH  
  0013 8d       [7]             RTC   
  0014          L14:    
  0014 c60000   [4]             LDA   smacState
  0017 2707     [3]             BEQ   L20 ;abs = 0020
  0019 410404   [4]             CBEQA #4,L20 ;abs = 0020
  001c a601     [2]             LDA   #1
  001e 8a       [3]             PULH  
  001f 8d       [7]             RTC   
  0020          L20:    
  0020 450000   [3]             LDHX  @u8TestBuffer
  0023 960000   [5]             STHX  pTestPacket
  0026 a604     [2]             LDA   #4
  0028 c70000   [4]             STA   smacState
  002b cd0000   [6]             JSR   PhyDisableContinuousTxRxMode
  002e cd0000   [6]             JSR   PhyDisableTxNoModulation
  0031 cd0000   [6]             JSR   PhyAbort
  0034 95       [2]             TSX   
  0035 7d       [3]             TST   ,X
  0036 260d     [3]             BNE   L45 ;abs = 0045
  0038 450000   [3]             LDHX  @smacFlags
  003b f6       [3]             LDA   ,X
  003c a4f7     [2]             AND   #-9
  003e f7       [2]             STA   ,X
  003f 4f       [1]             CLRA  
  0040 c70000   [4]             STA   smacState
  0043 2049     [3]             BRA   L8E ;abs = 008e
  0045          L45:    
  0045 f6       [3]             LDA   ,X
  0046 a102     [2]             CMP   #2
  0048 2608     [3]             BNE   L52 ;abs = 0052
  004a cd0000   [6]             JSR   PhyDisableTxNoModulation
  004d cd0000   [6]             JSR   PhyEnableContinuousTxRxMode
  0050 202e     [3]             BRA   L80 ;abs = 0080
  0052          L52:    
  0052 a103     [2]             CMP   #3
  0054 2608     [3]             BNE   L5E ;abs = 005e
  0056 cd0000   [6]             JSR   PhyEnableContinuousTxRxMode
  0059 cd0000   [6]             JSR   PhyEnableTxNoModulation
  005c 2022     [3]             BRA   L80 ;abs = 0080
  005e          L5E:    
  005e a101     [2]             CMP   #1
  0060 2613     [3]             BNE   L75 ;abs = 0075
  0062 cd0000   [6]             JSR   PhyDisableTxNoModulation
  0065 cd0000   [6]             JSR   PhyEnableContinuousTxRxMode
  0068 320000   [5]             LDHX  pTestPacket
  006b 89       [2]             PSHX  
  006c 8b       [2]             PSHH  
  006d 450000   [3]             LDHX  @smacLastDataRxParams
  0070 cd0000   [6]             JSR   PhyPlmeRxRequest
  0073 2017     [3]             BRA   L8C ;abs = 008c
  0075          L75:    
  0075 a104     [2]             CMP   #4
  0077 2615     [3]             BNE   L8E ;abs = 008e
  0079 450000   [3]             LDHX  @smacFlags
  007c f6       [3]             LDA   ,X
  007d aa08     [2]             ORA   #8
  007f f7       [2]             STA   ,X
  0080          L80:    
  0080 320000   [5]             LDHX  pTestPacket
  0083 89       [2]             PSHX  
  0084 8b       [2]             PSHH  
  0085 a601     [2]             LDA   #1
  0087 5f       [1]             CLRX  
  0088 8c       [1]             CLRH  
  0089 cd0000   [6]             JSR   PhyPdDataRequest
  008c          L8C:    
  008c a702     [2]             AIS   #2
  008e          L8E:    
  008e 4f       [1]             CLRA  
  008f 8a       [3]             PULH  
  0090 8d       [7]             RTC   
  949:  
  950:  
  951:  
  952:  
  953:  /***********************************************************************************/
  954:  /******************************** SMAC MCU primitives ******************************/
  955:  /***********************************************************************************/
  956:  
  957:  
  958:  /************************************************************************************
  959:  * SMACEnableInterrupts
  960:  * 
  961:  * This function enables the interrupts that are used by SMAC.
  962:  *
  963:  ************************************************************************************/
  964:  void SMACEnableInterrupts(void)
  965:  {
  966:    PhyEnableRadioInterrupts();
  0000 cd0000   [6]             JSR   PhyEnableRadioInterrupts
  967:  }
  0003 8d       [7]             RTC   
  968:  
  969:  /************************************************************************************
  970:  * SMACDisableInterrupts
  971:  * 
  972:  * This function disables the interrupts that are used by SMAC.
  973:  *
  974:  ************************************************************************************/
  975:  void SMACDisableInterrupts(void)
  976:  {
  977:    PhyDisableRadioInterrupts();
  0000 cd0000   [6]             JSR   PhyDisableRadioInterrupts
  978:  }
  0003 8d       [7]             RTC   
  979:  
  980:  
  981:  /************************************************************************************
  982:  *************************************************************************************
  983:  * private functions
  984:  *************************************************************************************
  985:  ************************************************************************************/
  986:  
  987:  /***********************************************************************************/
  988:  smacErrors_t SmacScanTheNextChannel(void)
  989:  {
  0000 a7fd     [2]             AIS   #-3
  990:    uint8_t  u8PhyRes;
  991:    uint16_t u16ChannelMask;
  992:  
  993:    /*Look for the next channel to scan*/
  994:    u16ChannelMask = 0x0001 << (uint8_t)(smacScanCurrentChannel - gChannel11_c);
  0002 c60000   [4]             LDA   smacScanCurrentChannel
  0005 a00b     [2]             SUB   #11
  0007 87       [2]             PSHA  
  0008 ae01     [2]             LDX   #1
  000a 9f       [1]             TXA   
  000b 5f       [1]             CLRX  
  000c cd0000   [6]             JSR   _ILSL
  000f 8a       [3]             PULH  
  0010 89       [2]             PSHX  
  0011 8a       [3]             PULH  
  0012 97       [1]             TAX   
  0013 9eff01   [5]             STHX  1,SP
  995:    while(!(u16ChannelMask & smacChannelsBeingScanned) && (u16ChannelMask))
  0016 2008     [3]             BRA   L20 ;abs = 0020
  0018          L18:    
  996:    {
  997:      smacScanCurrentChannel++;
  0018 450000   [3]             LDHX  @smacScanCurrentChannel
  001b 7c       [4]             INC   ,X
  998:      u16ChannelMask<<=1;
  001c 95       [2]             TSX   
  001d 6801     [5]             LSL   1,X
  001f 79       [4]             ROL   ,X
  0020          L20:    
  0020 c60001   [4]             LDA   smacChannelsBeingScanned:1
  0023 95       [2]             TSX   
  0024 e401     [3]             AND   1,X
  0026 87       [2]             PSHA  
  0027 c60000   [4]             LDA   smacChannelsBeingScanned
  002a f4       [3]             AND   ,X
  002b 87       [2]             PSHA  
  002c 8a       [3]             PULH  
  002d 88       [3]             PULX  
  002e 650000   [3]             CPHX  #0
  0031 2605     [3]             BNE   L38 ;abs = 0038
  0033 9efe01   [5]             LDHX  1,SP
  0036 26e0     [3]             BNE   L18 ;abs = 0018
  0038          L38:    
  999:    }
 1000:  
 1001:    if(gTotalChannels_c == smacScanCurrentChannel)
  0038 c60000   [4]             LDA   smacScanCurrentChannel
  003b a11b     [2]             CMP   #27
  003d 2604     [3]             BNE   L43 ;abs = 0043
 1002:    {
 1003:      return gErrorOutOfRange_c;
  003f a602     [2]             LDA   #2
  0041 201a     [3]             BRA   L5D ;abs = 005d
  0043          L43:    
 1004:    }
 1005:    else
 1006:    {
 1007:      u8PhyRes = PhyPlmeSetCurrentChannelRequest(smacScanCurrentChannel);
  0043 cd0000   [6]             JSR   PhyPlmeSetCurrentChannelRequest
  0046 95       [2]             TSX   
  0047 e702     [3]             STA   2,X
 1008:      if(!u8PhyRes)
  0049 2612     [3]             BNE   L5D ;abs = 005d
 1009:      {
 1010:        if(mSmacPerformingEDScan)
  004b c60000   [4]             LDA   smacFlags
  004e a540     [2]             BIT   #64
  0050 2706     [3]             BEQ   L58 ;abs = 0058
 1011:        {
 1012:          return (smacErrors_t)PhyPlmeEdRequest();
  0052 4f       [1]             CLRA  
  0053 cd0000   [6]             JSR   PhyPlmeCcaEdRequest
  0056 2005     [3]             BRA   L5D ;abs = 005d
  0058          L58:    
 1013:        }
 1014:        else
 1015:        {
 1016:          return (smacErrors_t)PhyPlmeCcaRequest(gCcaCCA_MODE1_c);
  0058 a601     [2]             LDA   #1
  005a cd0000   [6]             JSR   PhyPlmeCcaEdRequest
  005d          L5D:    
 1017:        }
 1018:      }
 1019:      else 
 1020:      {
 1021:        return (smacErrors_t)u8PhyRes;
 1022:      }
 1023:    }
 1024:  }
  005d a703     [2]             AIS   #3
  005f 8d       [7]             RTC   
 1025:   
 1026:  /*********************************************************/
 1027:  void SmacSetRxTimeout(zbClock24_t timeoutSymbols)
 1028:  {
  0000 a7fc     [2]             AIS   #-4
 1029:    zbClock24_t time;
 1030:    PhyTimeReadClock(&time);
  0002 95       [2]             TSX   
  0003 cd0000   [6]             JSR   PhyTimeReadClock
 1031:    time += timeoutSymbols + 4;
  0006 95       [2]             TSX   
  0007 af07     [2]             AIX   #7
  0009 cd0000   [6]             JSR   _LADD_RC
  000c 00000004         DC.L  4
  0010 aff9     [2]             AIX   #-7
  0012 89       [2]             PSHX  
  0013 8b       [2]             PSHH  
  0014 affc     [2]             AIX   #-4
  0016 cd0000   [6]             JSR   _LADD
  0019 af04     [2]             AIX   #4
  001b cd0000   [6]             JSR   _POP32
 1032:    PhyTimeSetEventTimeout(&time);
  001e 95       [2]             TSX   
  001f af04     [2]             AIX   #4
  0021 cd0000   [6]             JSR   PhyTimeSetEventTimeout
 1033:  }
  0024 a708     [2]             AIS   #8
  0026 8d       [7]             RTC   
 1034:  
 1035:  /*********************************************************/
 1036:  phyPacket_t * SmacFormatTxPacket(txPacket_t *psTxPacket)
 1037:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
 1038:    phyPacket_t * packetToPhy;
 1039:    
 1040:    packetToPhy = (phyPacket_t *)psTxPacket;
 1041:  
 1042:    if(FALSE == mPromiscuousModeEnabled)
  0002 c60000   [4]             LDA   smacFlags
  0005 a501     [2]             BIT   #1
  0007 260e     [3]             BNE   L17 ;abs = 0017
 1043:    {
 1044:      packetToPhy = (phyPacket_t *)psTxPacket;
 1045:      packetToPhy->frameLength += 2; //Add 2 for Code bytes
  0009 f6       [3]             LDA   ,X
  000a ab02     [2]             ADD   #2
  000c f7       [2]             STA   ,X
 1046:      packetToPhy->data[0] = 0x7E;
  000d a67e     [2]             LDA   #126
  000f e701     [3]             STA   1,X
 1047:      packetToPhy->data[1] = 0xFF;
  0011 a6ff     [2]             LDA   #-1
  0013 e702     [3]             STA   2,X
 1048:    }
  0015 200b     [3]             BRA   L22 ;abs = 0022
  0017          L17:    
 1049:    else
 1050:    {
 1051:      packetToPhy = (phyPacket_t *)&psTxPacket->smacPdu.reserved[1];
  0017 af02     [2]             AIX   #2
 1052:      packetToPhy->frameLength = psTxPacket->u8DataLength;
  0019 89       [2]             PSHX  
  001a 8b       [2]             PSHH  
  001b 9efe03   [5]             LDHX  3,SP
  001e f6       [3]             LDA   ,X
  001f 8a       [3]             PULH  
  0020 88       [3]             PULX  
  0021 f7       [2]             STA   ,X
  0022          L22:    
 1053:    }
 1054:    
 1055:    packetToPhy->frameLength += 2; //Add 2 for FCS
  0022 f6       [3]             LDA   ,X
  0023 ab02     [2]             ADD   #2
  0025 f7       [2]             STA   ,X
 1056:    
 1057:    return packetToPhy;
 1058:  }
  0026 a702     [2]             AIS   #2
  0028 8d       [7]             RTC   
 1059:   
 1060:    
 1061:     
 1062:  /***********************************************************************************/
 1063:  /****************************** PHY Callback Functions *****************************/
 1064:  /***********************************************************************************/
 1065:  
 1066:  /* Place it in NON_BANKED memory */
 1067:  #ifdef MEMORY_MODEL_BANKED
 1068:  #pragma CODE_SEG __NEAR_SEG NON_BANKED
 1069:  #else
 1070:  #pragma CODE_SEG DEFAULT
 1071:  #endif /* MEMORY_MODEL_BANKED */
 1072:  
 1073:  /***********************************************************************************/
 1074:  void PhyPdDataConfirm(void)
 1075:  {
  0000 a7fe     [2]             AIS   #-2
 1076:    if(mSmacStateTransmitting_c == smacState)
  0002 c60000   [4]             LDA   smacState
  0005 a101     [2]             CMP   #1
  0007 2623     [3]             BNE   L2C ;abs = 002c
 1077:    {
 1078:      if(!mPromiscuousModeEnabled)
  0009 c60000   [4]             LDA   smacFlags
  000c a501     [2]             BIT   #1
  000e 2608     [3]             BNE   L18 ;abs = 0018
 1079:      {
 1080:        smacProccesPacketPtr.smacTxPacketPointer->frameLength-=4;
  0010 320000   [5]             LDHX  smacProccesPacketPtr
  0013 f6       [3]             LDA   ,X
  0014 a004     [2]             SUB   #4
 1081:      }
  0016 2006     [3]             BRA   L1E ;abs = 001e
  0018          L18:    
 1082:      else
 1083:      {
 1084:        smacProccesPacketPtr.smacTxPacketPointer->frameLength-= 2;
  0018 320000   [5]             LDHX  smacProccesPacketPtr
  001b f6       [3]             LDA   ,X
  001c a002     [2]             SUB   #2
  001e          L1E:    
  001e 320000   [5]             LDHX  smacProccesPacketPtr
  0021 f7       [2]             STA   ,X
 1085:      }
 1086:      MCPSDataComfirm(txSuccessStatus_c);
  0022 4f       [1]             CLRA  
  0023 cd0000   [6]             JSR   MCPSDataComfirm
 1087:      smacState= mSmacStateIdle_c;
  0026 4f       [1]             CLRA  
  0027 c70000   [4]             STA   smacState
 1088:    }
  002a 2030     [3]             BRA   L5C ;abs = 005c
  002c          L2C:    
 1089:    else if(mSmacStatePerformingTest_c == smacState)
  002c a104     [2]             CMP   #4
  002e 262c     [3]             BNE   L5C ;abs = 005c
 1090:    {
 1091:      if(TRUE == mSmacPerformingPRBS9)
  0030 c60000   [4]             LDA   smacFlags
  0033 a508     [2]             BIT   #8
  0035 2725     [3]             BEQ   L5C ;abs = 005c
 1092:      {
 1093:        DelayMs(5);  
  0037 4505ff   [3]             LDHX  #1535
  003a 9eff01   [5]             STHX  1,SP
  003d          L3D:    
  003d 9d       [1]             NOP   
  003e 95       [2]             TSX   
  003f 6d01     [4]             TST   1,X
  0041 2601     [3]             BNE   L44 ;abs = 0044
  0043 7a       [4]             DEC   ,X
  0044          L44:    
  0044 6a01     [5]             DEC   1,X
  0046 9efe01   [5]             LDHX  1,SP
  0049 650000   [3]             CPHX  #0
  004c 26ef     [3]             BNE   L3D ;abs = 003d
 1094:        (void)PhyPdDataRequest(pTestPacket, gDataReq_NoAck_NoCca_Unslotted_c, NULL);
  004e 320000   [5]             LDHX  pTestPacket
  0051 89       [2]             PSHX  
  0052 8b       [2]             PSHH  
  0053 a601     [2]             LDA   #1
  0055 5f       [1]             CLRX  
  0056 8c       [1]             CLRH  
  0057 cd0000   [6]             JSR   PhyPdDataRequest
  005a a702     [2]             AIS   #2
  005c          L5C:    
 1095:      }
 1096:    }
 1097:  }
  005c a702     [2]             AIS   #2
  005e 81       [6]             RTS   
 1098:  
 1099:  
 1100:  /***********************************************************************************/
 1101:  void PhyPdDataIndication(void)
 1102:  {
 1103:    uint8_t  u8PhyRes;
 1104:  
 1105:    if(!mPromiscuousModeEnabled)
  0000 c60000   [4]             LDA   smacFlags
  0003 a501     [2]             BIT   #1
  0005 2609     [3]             BNE   L10 ;abs = 0010
 1106:    {
 1107:      smacProccesPacketPtr.smacRxPacketPointer->u8DataLength-=4;
  0007 320000   [5]             LDHX  smacProccesPacketPtr
  000a e602     [3]             LDA   2,X
  000c a004     [2]             SUB   #4
 1108:    }
  000e 2007     [3]             BRA   L17 ;abs = 0017
  0010          L10:    
 1109:    else
 1110:    {
 1111:      smacProccesPacketPtr.smacRxPacketPointer->u8DataLength=smacProccesPacketPtr.smacRxPacketPointer->smacPdu.reserved[1] - 2;
  0010 320000   [5]             LDHX  smacProccesPacketPtr
  0013 e604     [3]             LDA   4,X
  0015 a002     [2]             SUB   #2
  0017          L17:    
  0017 320000   [5]             LDHX  smacProccesPacketPtr
  001a e702     [3]             STA   2,X
 1112:    }
 1113:    
 1114:    if( ((!mPromiscuousModeEnabled) && (FALSE == areCodeBytesValid(smacProccesPacketPtr.smacRxPacketPointer)) )||
  001c c60000   [4]             LDA   smacFlags
  001f a501     [2]             BIT   #1
  0021 2611     [3]             BNE   L34 ;abs = 0034
  0023 320000   [5]             LDHX  smacProccesPacketPtr
  0026 e603     [3]             LDA   3,X
  0028 a17e     [2]             CMP   #126
  002a 2613     [3]             BNE   L3F ;abs = 003f
  002c 320000   [5]             LDHX  smacProccesPacketPtr
  002f e604     [3]             LDA   4,X
  0031 4c       [1]             INCA  
  0032 260b     [3]             BNE   L3F ;abs = 003f
  0034          L34:    
 1115:      (smacProccesPacketPtr.smacRxPacketPointer->u8DataLength > smacProccesPacketPtr.smacRxPacketPointer->u8MaxDataLength))
  0034 320000   [5]             LDHX  smacProccesPacketPtr
  0037 f6       [3]             LDA   ,X
  0038 320000   [5]             LDHX  smacProccesPacketPtr
  003b e102     [3]             CMP   2,X
  003d 242d     [3]             BCC   L6C ;abs = 006c
  003f          L3F:    
 1116:    {
 1117:      u8PhyRes = PhyPlmeRxRequest((phyPacket_t *)&(smacProccesPacketPtr.smacRxPacketPointer->u8DataLength), &smacLastDataRxParams);
  003f 320000   [5]             LDHX  smacProccesPacketPtr
  0042 af02     [2]             AIX   #2
  0044 89       [2]             PSHX  
  0045 8b       [2]             PSHH  
  0046 450000   [3]             LDHX  @smacLastDataRxParams
  0049 cd0000   [6]             JSR   PhyPlmeRxRequest
  004c a702     [2]             AIS   #2
 1118:      if(!u8PhyRes){
  004e 4d       [1]             TSTA  
  004f 2618     [3]             BNE   L69 ;abs = 0069
 1119:        if(mSmacTimeoutAsked)
  0051 c60000   [4]             LDA   smacFlags
  0054 a510     [2]             BIT   #16
  0056 2728     [3]             BEQ   L80 ;abs = 0080
 1120:        {
 1121:          SmacSetRxTimeout((zbClock24_t)smacTimeout);
  0058 320002   [5]             LDHX  smacTimeout:2
  005b 89       [2]             PSHX  
  005c 8b       [2]             PSHH  
  005d 320000   [5]             LDHX  smacTimeout
  0060 89       [2]             PSHX  
  0061 8b       [2]             PSHH  
  0062 ac000000 [8]             CALL  SmacSetRxTimeout
  0066 a704     [2]             AIS   #4
  0068 81       [6]             RTS   
  0069          L69:    
 1122:        }
 1123:      }else{
 1124:        smacProccesPacketPtr.smacRxPacketPointer->rxStatus = rxAbortedStatus_c;
  0069 a604     [2]             LDA   #4
  006b 65       [3]             SKIP2 L6E ;abs = 006e
  006c          L6C:    
 1125:        PhyTimeDisableEventTimeout();
 1126:        MCPSDataIndication(smacProccesPacketPtr.smacRxPacketPointer);
 1127:        smacState = mSmacStateIdle_c;
 1128:      }
 1129:    }
 1130:    else
 1131:    {
 1132:        smacProccesPacketPtr.smacRxPacketPointer->rxStatus = rxSuccessStatus_c;
  006c a602     [2]             LDA   #2
  006e          L6E:    
  006e 320000   [5]             LDHX  smacProccesPacketPtr
  0071 e701     [3]             STA   1,X
 1133:        PhyTimeDisableEventTimeout();
  0073 cd0000   [6]             JSR   PhyTimeDisableEventTimeout
 1134:        MCPSDataIndication(smacProccesPacketPtr.smacRxPacketPointer);
  0076 320000   [5]             LDHX  smacProccesPacketPtr
  0079 cd0000   [6]             JSR   MCPSDataIndication
 1135:        smacState= mSmacStateIdle_c;
  007c 4f       [1]             CLRA  
  007d c70000   [4]             STA   smacState
  0080          L80:    
 1136:    }
 1137:  }
  0080 81       [6]             RTS   
 1138:  
 1139:  /***********************************************************************************/
 1140:  void PhyPlmeCcaConfirm(bool_t channelInUse)
 1141:  {
  0000 87       [2]             PSHA  
 1142:    smacErrors_t scanRes;
 1143:    smacProccesPacketPtr.smacScanResultsPointer[smacScanCurrentChannel - gChannel11_c] = channelInUse;
  0001 c60000   [4]             LDA   smacScanCurrentChannel
  0004 8c       [1]             CLRH  
  0005 97       [1]             TAX   
  0006 aff5     [2]             AIX   #-11
  0008 89       [2]             PSHX  
  0009 8b       [2]             PSHH  
  000a 320000   [5]             LDHX  smacProccesPacketPtr
  000d 9f       [1]             TXA   
  000e 8b       [2]             PSHH  
  000f 95       [2]             TSX   
  0010 eb02     [3]             ADD   2,X
  0012 e702     [3]             STA   2,X
  0014 86       [3]             PULA  
  0015 e901     [3]             ADC   1,X
  0017 87       [2]             PSHA  
  0018 ee02     [3]             LDX   2,X
  001a 9ee604   [4]             LDA   4,SP
  001d 8a       [3]             PULH  
  001e f7       [2]             STA   ,X
 1144:    smacScanCurrentChannel++;
  001f 450000   [3]             LDHX  @smacScanCurrentChannel
  0022 7c       [4]             INC   ,X
 1145:    scanRes = SmacScanTheNextChannel();
  0023 ac000000 [8]             CALL  SmacScanTheNextChannel
 1146:    
 1147:    if(scanRes)
  0027 4d       [1]             TSTA  
  0028 a702     [2]             AIS   #2
  002a 271c     [3]             BEQ   L48 ;abs = 0048
 1148:    {
 1149:      smacClearestChann = gChannelOutOfRange_c; 
  002c a61b     [2]             LDA   #27
  002e c70000   [4]             STA   smacClearestChann
 1150:      (void)PhyPlmeSetCurrentChannelRequest(smacCurrentChannel);
  0031 c60000   [4]             LDA   smacCurrentChannel
  0034 cd0000   [6]             JSR   PhyPlmeSetCurrentChannelRequest
 1151:      MLMEScanComfirm(smacClearestChann);
  0037 c60000   [4]             LDA   smacClearestChann
  003a cd0000   [6]             JSR   MLMEScanComfirm
 1152:      mSmacPerformingCCAScan = FALSE;
  003d 450000   [3]             LDHX  @smacFlags
  0040 f6       [3]             LDA   ,X
  0041 a4df     [2]             AND   #-33
  0043 f7       [2]             STA   ,X
 1153:      smacState= mSmacStateIdle_c;
  0044 4f       [1]             CLRA  
  0045 c70000   [4]             STA   smacState
  0048          L48:    
 1154:    }
 1155:  }
  0048 8a       [3]             PULH  
  0049 81       [6]             RTS   
 1156:  
 1157:  /***********************************************************************************/
 1158:  void PhyPlmeEdConfirm(uint8_t energyLevel)
 1159:  {
  0000 8b       [2]             PSHH  
 1160:    smacErrors_t scanRes;
 1161:    
 1162:    if(mSmacPerformingED)
  0001 95       [2]             TSX   
  0002 f7       [2]             STA   ,X
  0003 c60000   [4]             LDA   smacFlags
  0006 2a0b     [3]             BPL   L13 ;abs = 0013
 1163:    {
 1164:      smacEdValue = energyLevel; 
  0008 fe       [3]             LDX   ,X
  0009 cf0000   [4]             STX   smacEdValue
 1165:      mSmacPerformingED = FALSE;
  000c a47f     [2]             AND   #127
  000e c70000   [4]             STA   smacFlags
 1166:    }
 1167:    else if(mSmacPerformingEDScan)
 1168:    {
 1169:      if(energyLevel < smacEdValue)
 1170:      {
 1171:        smacEdValue = energyLevel;
 1172:        smacClearestChann = smacScanCurrentChannel;
 1173:      }
 1174:      smacProccesPacketPtr.smacScanResultsPointer[smacScanCurrentChannel - gChannel11_c] = energyLevel; 
 1175:      smacScanCurrentChannel++;
 1176:      scanRes = SmacScanTheNextChannel();
 1177:      
 1178:      if(scanRes)
 1179:      {
 1180:        MLMEScanComfirm(smacClearestChann);
 1181:        (void)PhyPlmeSetCurrentChannelRequest(smacCurrentChannel);
 1182:        mSmacPerformingEDScan  = FALSE;
 1183:        smacState= mSmacStateIdle_c;
 1184:      }
 1185:    }
 1186:  }
  0011 8a       [3]             PULH  
  0012 81       [6]             RTS   
  0013          L13:    
  0013 a540     [2]             BIT   #64
  0015 2751     [3]             BEQ   L68 ;abs = 0068
  0017 f6       [3]             LDA   ,X
  0018 c10000   [4]             CMP   smacEdValue
  001b 2409     [3]             BCC   L26 ;abs = 0026
  001d c70000   [4]             STA   smacEdValue
  0020 ce0000   [4]             LDX   smacScanCurrentChannel
  0023 cf0000   [4]             STX   smacClearestChann
  0026          L26:    
  0026 ce0000   [4]             LDX   smacScanCurrentChannel
  0029 87       [2]             PSHA  
  002a 8c       [1]             CLRH  
  002b aff5     [2]             AIX   #-11
  002d 89       [2]             PSHX  
  002e 8b       [2]             PSHH  
  002f 320000   [5]             LDHX  smacProccesPacketPtr
  0032 9f       [1]             TXA   
  0033 8b       [2]             PSHH  
  0034 95       [2]             TSX   
  0035 eb02     [3]             ADD   2,X
  0037 e702     [3]             STA   2,X
  0039 86       [3]             PULA  
  003a e901     [3]             ADC   1,X
  003c 87       [2]             PSHA  
  003d ee02     [3]             LDX   2,X
  003f 9ee604   [4]             LDA   4,SP
  0042 8a       [3]             PULH  
  0043 f7       [2]             STA   ,X
  0044 450000   [3]             LDHX  @smacScanCurrentChannel
  0047 7c       [4]             INC   ,X
  0048 ac000000 [8]             CALL  SmacScanTheNextChannel
  004c 4d       [1]             TSTA  
  004d a703     [2]             AIS   #3
  004f 2717     [3]             BEQ   L68 ;abs = 0068
  0051 c60000   [4]             LDA   smacClearestChann
  0054 cd0000   [6]             JSR   MLMEScanComfirm
  0057 c60000   [4]             LDA   smacCurrentChannel
  005a cd0000   [6]             JSR   PhyPlmeSetCurrentChannelRequest
  005d 450000   [3]             LDHX  @smacFlags
  0060 f6       [3]             LDA   ,X
  0061 a4bf     [2]             AND   #-65
  0063 f7       [2]             STA   ,X
  0064 4f       [1]             CLRA  
  0065 c70000   [4]             STA   smacState
  0068          L68:    
  0068 8a       [3]             PULH  
  0069 81       [6]             RTS   
 1187:  
 1188:  /***********************************************************************************/
 1189:  void PhyPlmeSyncLossIndication(void)
 1190:  {
 1191:    uint8_t  u8PhyRes;
 1192:    if(mSmacStateReceiving_c == smacState)
  0000 c60000   [4]             LDA   smacState
  0003 a102     [2]             CMP   #2
  0005 2627     [3]             BNE   L2E ;abs = 002e
 1193:    {
 1194:      u8PhyRes = PhyPlmeRxRequest((phyPacket_t *)&(smacProccesPacketPtr.smacRxPacketPointer->u8DataLength), &smacLastDataRxParams);
  0007 320000   [5]             LDHX  smacProccesPacketPtr
  000a af02     [2]             AIX   #2
  000c 89       [2]             PSHX  
  000d 8b       [2]             PSHH  
  000e 450000   [3]             LDHX  @smacLastDataRxParams
  0011 cd0000   [6]             JSR   PhyPlmeRxRequest
  0014 a702     [2]             AIS   #2
 1195:      if(u8PhyRes)
  0016 4d       [1]             TSTA  
  0017 2749     [3]             BEQ   L62 ;abs = 0062
 1196:      {
 1197:        smacProccesPacketPtr.smacRxPacketPointer->rxStatus = rxAbortedStatus_c;
  0019 a604     [2]             LDA   #4
  001b 320000   [5]             LDHX  smacProccesPacketPtr
  001e e701     [3]             STA   1,X
 1198:        PhyTimeDisableEventTimeout();
  0020 cd0000   [6]             JSR   PhyTimeDisableEventTimeout
 1199:        MCPSDataIndication(smacProccesPacketPtr.smacRxPacketPointer);
  0023 320000   [5]             LDHX  smacProccesPacketPtr
  0026 cd0000   [6]             JSR   MCPSDataIndication
 1200:        smacState= mSmacStateIdle_c;
  0029 4f       [1]             CLRA  
  002a c70000   [4]             STA   smacState
  002d 81       [6]             RTS   
  002e          L2E:    
 1201:      }
 1202:    }
 1203:    else if(mSmacStateTransmitting_c == smacState)
  002e a101     [2]             CMP   #1
  0030 260f     [3]             BNE   L41 ;abs = 0041
 1204:    {
 1205:      (void)PhyPdDataRequest(smacProccesPacketPtr.smacTxPacketPointer, gDataReq_NoAck_NoCca_Unslotted_c, NULL);
  0032 320000   [5]             LDHX  smacProccesPacketPtr
  0035 89       [2]             PSHX  
  0036 8b       [2]             PSHH  
  0037 a601     [2]             LDA   #1
  0039 5f       [1]             CLRX  
  003a 8c       [1]             CLRH  
  003b cd0000   [6]             JSR   PhyPdDataRequest
  003e a702     [2]             AIS   #2
 1206:    }
  0040 81       [6]             RTS   
  0041          L41:    
 1207:    else if(mSmacStateScanningChannels_c == smacState)
  0041 a103     [2]             CMP   #3
  0043 2605     [3]             BNE   L4A ;abs = 004a
 1208:    {
 1209:      (void)SmacScanTheNextChannel();
  0045 ac000000 [8]             CALL  SmacScanTheNextChannel
 1210:    }
  0049 81       [6]             RTS   
  004a          L4A:    
 1211:    else if(TRUE == mSmacPerformingED)
  004a c60000   [4]             LDA   smacFlags
  004d 2a13     [3]             BPL   L62 ;abs = 0062
 1212:    {
 1213:      if(PhyPlmeEdRequest())
  004f 4f       [1]             CLRA  
  0050 cd0000   [6]             JSR   PhyPlmeCcaEdRequest
  0053 4d       [1]             TSTA  
  0054 270c     [3]             BEQ   L62 ;abs = 0062
 1214:      {
 1215:        smacEdValue = 0xFF;
  0056 a6ff     [2]             LDA   #-1
  0058 c70000   [4]             STA   smacEdValue
 1216:        mSmacPerformingED = FALSE;
  005b 450000   [3]             LDHX  @smacFlags
  005e f6       [3]             LDA   ,X
  005f a47f     [2]             AND   #127
  0061 f7       [2]             STA   ,X
  0062          L62:    
 1217:      }
 1218:    }
 1219:  }
  0062 81       [6]             RTS   
 1220:  
 1221:  /***********************************************************************************/
 1222:  void PhyPlmeResetIndication(void)
 1223:  {
 1224:    MLMEResetIndication();
  0000 cc0000   [4]             JMP   MLMEResetIndication
 1225:  }
 1226:  
 1227:  /***********************************************************************************/
 1228:  void    PhyPlmeWakeComfirm(void)
 1229:  {
 1230:    MLMEWakeComfirm();
  0000 cc0000   [4]             JMP   MLMEWakeComfirm
 1231:  }
 1232:  
 1233:  /***********************************************************************************/
 1234:  void PhyTimeRxTimeoutIndication(void)
 1235:  {
 1236:    smacProccesPacketPtr.smacRxPacketPointer->rxStatus = rxTimeOutStatus_c;
  0000 a603     [2]             LDA   #3
  0002 320000   [5]             LDHX  smacProccesPacketPtr
  0005 e701     [3]             STA   1,X
 1237:    MCPSDataIndication(smacProccesPacketPtr.smacRxPacketPointer);
  0007 320000   [5]             LDHX  smacProccesPacketPtr
  000a cd0000   [6]             JSR   MCPSDataIndication
 1238:    smacState= mSmacStateIdle_c;
  000d 4f       [1]             CLRA  
  000e c70000   [4]             STA   smacState
 1239:  }
  0011 81       [6]             RTS   
 1240:  
 1241:  /***********************************************************************************/
 1242:  void PhyTimeStartEventIndication(void)
 1243:  {
 1244:    
 1245:  }
  0000 81       [6]             RTS   
 1246:  
 1247:  #pragma CODE_SEG DEFAULT
 1248:  
 1249:  
 1250:  
 1251:  
