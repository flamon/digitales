ANSI-C/cC++ Compiler for HC08 V-5.0.39 Build 11346, Dec 13 2011

    1:  /************************************************************************************
    2:  * Source file for MC1323x platform ASM driver, and software security driver
    3:  * for HCS08GT/GB  and HCS08QE
    4:  *
    5:  * (c) Copyright 2010, Freescale, Inc.  All rights reserved.
    6:  *
    7:  * Freescale Confidential Proprietary
    8:  *
    9:  * No part of this document must be reproduced in any form - including copied,
   10:  * transcribed, printed or by any electronic means - without specific written
   11:  * permission from Freescale.
   12:  ************************************************************************************/
   13:  
   14:  #include "ASM.h"
   15:  
   16:  #if gAsmSupported_d == TRUE
   17:  
   18:  /************************************************************************************
   19:  *************************************************************************************
   20:  * Private macros
   21:  *************************************************************************************
   22:  ************************************************************************************/
   23:  
   24:  
   25:  /************************************************************************************
   26:  *************************************************************************************
   27:  * Private prototypes
   28:  *************************************************************************************
   29:  ************************************************************************************/
   30:  
   31:  asmErr_t mCipherDecipher(void);
   32:  
   33:  #ifdef gMcs08Gt60Platform_d
   34:    void mAesAddKeyByteSubShiftKeyExpand(void);
   35:    uint8_t mxTime(uint8_t x);
   36:  #endif
   37:  
   38:  #ifdef gMcs08qe128Platform_d
   39:    void mAesAddKeyByteSubShiftKeyExpand(void);
   40:    uint8_t mxTime(uint8_t x);
   41:  #endif
   42:  
   43:  
   44:  /************************************************************************************
   45:  *************************************************************************************
   46:  * Private type definitions
   47:  *************************************************************************************
   48:  ************************************************************************************/
   49:  
   50:  
   51:  /************************************************************************************
   52:  *************************************************************************************
   53:  * Public memory declarations
   54:  *************************************************************************************
   55:  ************************************************************************************/
   56:  
   57:          
   58:  /************************************************************************************
   59:  *************************************************************************************
   60:  * Private memory declarations
   61:  *************************************************************************************
   62:  ************************************************************************************/
   63:  
   64:  #ifdef gMcs08Gt60Platform_d
   65:  
   66:    #define mSBox_c(x) mBox_c[x] 
   67:  
   68:    const uint8_t mBox_c[256] = 
   69:    {
   70:     99, 124, 119, 123, 242, 107, 111, 197,
   71:     48,   1, 103,  43, 254, 215, 171, 118,
   72:    202, 130, 201, 125, 250,  89,  71, 240,
   73:    173, 212, 162, 175, 156, 164, 114, 192,
   74:    183, 253, 147,  38,  54,  63, 247, 204,
   75:     52, 165, 229, 241, 113, 216,  49,  21,
   76:      4, 199,  35, 195,  24, 150,   5, 154,
   77:      7,  18, 128, 226, 235,  39, 178, 117,
   78:      9, 131,  44,  26,  27, 110,  90, 160,
   79:     82,  59, 214, 179,  41, 227,  47, 132,
   80:     83, 209,   0, 237,  32, 252, 177,  91,
   81:    106, 203, 190,  57,  74,  76,  88, 207,
   82:    208, 239, 170, 251,  67,  77,  51, 133,
   83:     69, 249,   2, 127,  80,  60, 159, 168,
   84:     81, 163,  64, 143, 146, 157,  56, 245,
   85:    188, 182, 218,  33,  16, 255, 243, 210,
   86:    205,  12,  19, 236,  95, 151,  68,  23,
   87:    196, 167, 126,  61, 100,  93,  25, 115,
   88:     96, 129,  79, 220,  34,  42, 144, 136,
   89:     70, 238, 184,  20, 222,  94,  11, 219,
   90:    224,  50,  58,  10,  73,   6,  36,  92,
   91:    194, 211, 172,  98, 145, 149, 228, 121,
   92:    231, 200,  55, 109, 141, 213,  78, 169,
   93:    108,  86, 244, 234, 101, 122, 174,   8,
   94:    186, 120,  37,  46,  28, 166, 180, 198,
   95:    232, 221, 116,  31,  75, 189, 139, 138,
   96:    112,  62, 181, 102,  72,   3, 246,  14,
   97:     97,  53,  87, 185, 134, 193,  29, 158,
   98:    225, 248, 152,  17, 105, 217, 142, 148,
   99:    155,  30, 135, 233, 206,  85,  40, 223,
  100:    140, 161, 137,  13, 191, 230,  66, 104,
  101:     65, 153,  45,  15, 176,  84, 187,  22
  102:    };
  103:   
  104:  
  105:    uint8_t                * mpMacAccPreload;
  106:    static uint8_t         * mpCtr;
  107:    static uint8_t         * mpKey;
  108:    static uint8_t           mAesTmp;
  109:    static uint8_t           mAesTmp2;
  110:    static uint8_t           mAesRound;
  111:    static uint8_t           mAesState[16];
  112:    static uint8_t           mAesTempKey[16]; 
  113:  
  114:  #endif
  115:  
  116:  
  117:  #ifdef gMcs08qe128Platform_d
  118:  
  119:    #define mSBox_c(x) mBox_c[x] 
  120:  
  121:    const uint8_t mBox_c[256] = 
  122:    {
  123:     99, 124, 119, 123, 242, 107, 111, 197,
  124:     48,   1, 103,  43, 254, 215, 171, 118,
  125:    202, 130, 201, 125, 250,  89,  71, 240,
  126:    173, 212, 162, 175, 156, 164, 114, 192,
  127:    183, 253, 147,  38,  54,  63, 247, 204,
  128:     52, 165, 229, 241, 113, 216,  49,  21,
  129:      4, 199,  35, 195,  24, 150,   5, 154,
  130:      7,  18, 128, 226, 235,  39, 178, 117,
  131:      9, 131,  44,  26,  27, 110,  90, 160,
  132:     82,  59, 214, 179,  41, 227,  47, 132,
  133:     83, 209,   0, 237,  32, 252, 177,  91,
  134:    106, 203, 190,  57,  74,  76,  88, 207,
  135:    208, 239, 170, 251,  67,  77,  51, 133,
  136:     69, 249,   2, 127,  80,  60, 159, 168,
  137:     81, 163,  64, 143, 146, 157,  56, 245,
  138:    188, 182, 218,  33,  16, 255, 243, 210,
  139:    205,  12,  19, 236,  95, 151,  68,  23,
  140:    196, 167, 126,  61, 100,  93,  25, 115,
  141:     96, 129,  79, 220,  34,  42, 144, 136,
  142:     70, 238, 184,  20, 222,  94,  11, 219,
  143:    224,  50,  58,  10,  73,   6,  36,  92,
  144:    194, 211, 172,  98, 145, 149, 228, 121,
  145:    231, 200,  55, 109, 141, 213,  78, 169,
  146:    108,  86, 244, 234, 101, 122, 174,   8,
  147:    186, 120,  37,  46,  28, 166, 180, 198,
  148:    232, 221, 116,  31,  75, 189, 139, 138,
  149:    112,  62, 181, 102,  72,   3, 246,  14,
  150:     97,  53,  87, 185, 134, 193,  29, 158,
  151:    225, 248, 152,  17, 105, 217, 142, 148,
  152:    155,  30, 135, 233, 206,  85,  40, 223,
  153:    140, 161, 137,  13, 191, 230,  66, 104,
  154:     65, 153,  45,  15, 176,  84, 187,  22
  155:    };
  156:   
  157:  
  158:    uint8_t                * mpMacAccPreload;
  159:    static uint8_t         * mpCtr;
  160:    static uint8_t         * mpKey;
  161:    static uint8_t           mAesTmp;
  162:    static uint8_t           mAesTmp2;
  163:    static uint8_t           mAesRound;
  164:    static uint8_t           mAesState[16];
  165:    static uint8_t           mAesTempKey[16]; 
  166:  
  167:  #endif
  168:  
  169:  
  170:  static uint8_t         * mpData;
  171:  static uint8_t         * mpCbcMacVal;
  172:  static uint8_t           mBufferLength;
  173:  static asmAesState_t     mu8AsmState;
  174:  static asmMode_t         mCipherMode;
  175:  static asmCallbackFunc_t mCallbackFunc;
  176:  static asmAction_t       mAsmAction;
  177:  static bool_t            mCcmSecondRound;
  178:  static bool_t            mLoadCbcPrevMac;
  179:  
  180:  
  181:  /************************************************************************************
  182:  *************************************************************************************
  183:  * Public functions
  184:  *************************************************************************************
  185:  ************************************************************************************/
  186:  
  187:  /************************************************************************************
  188:  * Asm_Init
  189:  *
  190:  * This function is called to initialize the ASM driver, ASM control registers and
  191:  * to perform the AES self-test in the MC1323x platform. For HCS08GT/GB, MC1321x, 
  192:  * and HCS08QE platforms the function only initialize the state machine.
  193:  *
  194:  ************************************************************************************/
  195:  
  196:  
  197:  asmErr_t Asm_Init()
  198:  {   
  199:  
  200:  #ifdef gMc1323xPlatform_d
  201:   
  202:    uint16_t timeoutCycles;
  203:   
  204:    mAsmCntl2Reg = (uint8_t)0x00;    
  205:    mAsmCntl1Reg = AES_CTRL1_CLEAR | AES_CTRL1_AESMSK;
  206:  
  207:   
  208:    /*See if the test was already performed */
  209:    if(mAsmCntl2Reg & AES_CTRL2_TSTPAS)   
  210:    {
  211:      return gAsmErrNoError_c;
  212:    }
  213:   
  214:    /* Initialize the AES self test */
  215:    mAsmCntl1Reg = AES_CTRL1_START | AES_CTRL1_SELFTST | AES_CTRL1_AESMSK;
  216:   
  217:    /* Poll for the DONE Flag. If The DONE flag is not set on the SelfTest 
  218:       the while loop takes 3330 cycles  */
  219:    
  220:    timeoutCycles = gAsmMaxSelfTestCycles; 
  221:   
  222:    while(!(mAsmCntl2Reg & AES_CTRL2_DONE) && (timeoutCycles--)); 
  223:   
  224:    if(mAsmCntl2Reg & AES_CTRL2_DONE)
  225:    {    
  226:      if(!(mAsmCntl2Reg & AES_CTRL2_TSTPAS))
  227:      {
  228:        return gAsmErrSelfTestFail_c;
  229:      }
  230:    }
  231:    
  232:    else
  233:    {
  234:      /* Self test timeout */
  235:      /* Clear the SELFTST bit to get out from this mode */
  236:      mAsmCntl1Reg = AES_CTRL1_AESMSK;
  237:      return gAsmErrInternalTimeout_c;
  238:    }
  239:    
  240:  #endif
  241:    
  242:    mu8AsmState = gAsmStateIdle_c;  
  0000 4f       [1]             CLRA  
  0001 c70000   [4]             STA   mu8AsmState
  243:    return gAsmErrNoError_c;
  244:   
  245:  }
  0004 8d       [7]             RTC   
  246:  
  247:  /************************************************************************************
  248:  * Asm_CipherDecipherRequest
  249:  *
  250:  * This function configures the cipher operation, set the key, counter, a preload MAC
  251:  * (Message Autentication Code) in the respective ASM registers. For platforms
  252:  * without a cipher engine it set the respective parameter in the arrays used for
  253:  * for the cipher opertation.
  254:  *
  255:  * Caution: The input data buffer is overridden with the ciphered or deciphered data.
  256:  * The buffer length must be multiple of 16 bytes or 128 bits.
  257:  *
  258:  ************************************************************************************/
  259:  
  260:  asmErr_t Asm_CipherDecipherRequest(
  261:  asmConfig_t asmConfig, 
  262:  uint8_t * pData, 
  263:  asmAction_t asmAction)
  264:  {
  0000 89       [2]             PSHX  
  0001 8b       [2]             PSHH  
  0002 87       [2]             PSHA  
  265:                                                                         
  266:    if(gAsmStateIdle_c == mu8AsmState) 
  0003 c60000   [4]             LDA   mu8AsmState
  0006 2703     [3]             BEQ   LB ;abs = 000b
  0008 cc0095   [4]             JMP   L95 ;abs = 0095
  000b          LB:     
  267:    {
  268:      if( (pData == NULL) || (NULL == asmConfig.pCallback) || (NULL == asmConfig.pKey))
  000b 650000   [3]             CPHX  #0
  000e 272e     [3]             BEQ   L3E ;abs = 003e
  0010 9efe12   [5]             LDHX  18,SP
  0013 2729     [3]             BEQ   L3E ;abs = 003e
  0015 9efe07   [5]             LDHX  7,SP
  0018 2724     [3]             BEQ   L3E ;abs = 003e
  269:      {    
  270:        return gAsmErrNullPointer_c;
  271:      }
  272:       
  273:      if( (NULL == asmConfig.pCtr) && (gAsmModeCtr_c == asmConfig.CipherMode) )
  001a 9efe09   [5]             LDHX  9,SP
  001d 2605     [3]             BNE   L24 ;abs = 0024
  001f 95       [2]             TSX   
  0020 6d10     [4]             TST   16,X
  0022 271a     [3]             BEQ   L3E ;abs = 003e
  0024          L24:    
  274:      {
  275:        return gAsmErrNullPointer_c;
  276:      }
  277:    
  278:      if( (NULL == asmConfig.pCtr) && (gAsmModeCcm_c == asmConfig.CipherMode) )
  0024 9efe09   [5]             LDHX  9,SP
  0027 2606     [3]             BNE   L2F ;abs = 002f
  0029 95       [2]             TSX   
  002a e610     [3]             LDA   16,X
  002c 41020f   [4]             CBEQA #2,L3E ;abs = 003e
  002f          L2F:    
  279:      {
  280:        return gAsmErrNullPointer_c;
  281:      } 
  282:   
  283:      if( (NULL == asmConfig.pCbcMacVal) && ((gAsmModeCbcMac_c == asmConfig.CipherMode) ||\
  002f 9efe0b   [5]             LDHX  11,SP
  0032 260e     [3]             BNE   L42 ;abs = 0042
  0034 95       [2]             TSX   
  0035 e610     [3]             LDA   16,X
  0037 410104   [4]             CBEQA #1,L3E ;abs = 003e
  003a a102     [2]             CMP   #2
  003c 2604     [3]             BNE   L42 ;abs = 0042
  003e          L3E:    
  284:          (gAsmModeCcm_c == asmConfig.CipherMode)) )
  285:      {
  286:        return gAsmErrNullPointer_c;
  003e a606     [2]             LDA   #6
  0040 2055     [3]             BRA   L97 ;abs = 0097
  0042          L42:    
  287:      } 
  288:    
  289:      if( (gAsmModeMax_c <= asmConfig.CipherMode) || (0 != (asmConfig.u8BufferLength % mAsmBlockSize_c)) )
  0042 95       [2]             TSX   
  0043 e610     [3]             LDA   16,X
  0045 a104     [2]             CMP   #4
  0047 2406     [3]             BCC   L4F ;abs = 004f
  0049 e613     [3]             LDA   19,X
  004b a50f     [2]             BIT   #15
  004d 2704     [3]             BEQ   L53 ;abs = 0053
  004f          L4F:    
  290:      {   
  291:        return gAsmErrInvalidParameter_c;
  004f a603     [2]             LDA   #3
  0051 2044     [3]             BRA   L97 ;abs = 0097
  0053          L53:    
  292:      }
  293:    
  294:   
  295:      else
  296:      { 
  297:        mpData = pData;
  0053 9efe02   [5]             LDHX  2,SP
  0056 960000   [5]             STHX  mpData
  298:        mCipherMode = asmConfig.CipherMode;
  0059 95       [2]             TSX   
  005a ee10     [3]             LDX   16,X
  005c cf0000   [4]             STX   mCipherMode
  299:        mBufferLength = asmConfig.u8BufferLength; 
  005f c70000   [4]             STA   mBufferLength
  300:        mAsmAction = asmAction;
  0062 95       [2]             TSX   
  0063 f6       [3]             LDA   ,X
  0064 c70000   [4]             STA   mAsmAction
  301:        mCallbackFunc = asmConfig.pCallback;
  0067 9efe12   [5]             LDHX  18,SP
  006a 960000   [5]             STHX  mCallbackFunc
  302:        mpCbcMacVal = asmConfig.pCbcMacVal;
  006d 9efe0b   [5]             LDHX  11,SP
  0070 960000   [5]             STHX  mpCbcMacVal
  303:        mCcmSecondRound = FALSE;
  0073 4f       [1]             CLRA  
  0074 c70000   [4]             STA   mCcmSecondRound
  304:        mLoadCbcPrevMac = FALSE;
  0077 c70000   [4]             STA   mLoadCbcPrevMac
  305:       
  306:  #ifdef gMc1323xPlatform_d
  307:     
  308:        if(!(mAsmCntl2Reg & AES_CTRL2_TSTPAS))
  309:        {   
  310:          return gAsmErrSelfTestNotPerformed_c;   
  311:        } 
  312:  
  313:        /* Clear previous AES encryption/decryption modes.  Clear the ASM memory*/
  314:        mAsmCntl1Reg = (uint8_t)AES_CTRL1_CLEAR | AES_CTRL1_AESMSK; 
  315:    
  316:        /*Load the MAC preload if necessary. The ASM memory is already
  317:          cleared if a MAC preload was not provided*/ 
  318:        if(((gAsmModeCbcMac_c == mCipherMode) || (gAsmModeCcm_c == mCipherMode)) && \
  319:            (NULL != asmConfig.pMacAccPreload))
  320:        {
  321:          mAsmCntl2Reg = (uint8_t)((mAsmCntl2Reg & mAsmCntl1RegModesMask_c) | \
  322:                         (uint8_t)AES_CTRL2_REGTYPE_MAC);
  323:          MemoryCpy((void*)&mAsmD0Reg, asmConfig.pMacAccPreload, mAsmBlockSize_c);
  324:          mAsmCntl1Reg |= AES_CTRL1_LOADMAC;  
  325:        }
  326:      
  327:        /* Set the AES engine encryption/decryption key */
  328:        mAsmCntl2Reg = (mAsmCntl2Reg & mAsmCntl1RegModesMask_c) | (uint8_t)AES_CTRL2_REGTYPE_KEY;
  329:        MemoryCpy((void*)&mAsmD0Reg, asmConfig.pKey, mAsmBlockSize_c);
  330:      
  331:      
  332:        /* Set the AES engine encryption/decryption mode */
  333:        if((gAsmModeCbcMac_c == mCipherMode) || ((gAsmModeCcm_c == mCipherMode) && \
  334:           (gAsmCipher_c == mAsmAction)))
  335:        {
  336:          mAsmCntl1Reg |= AES_CTRL1_CBC; 
  337:        }
  338:    
  339:        if((gAsmModeCtr_c == mCipherMode) || (gAsmModeCcm_c == mCipherMode))
  340:        {
  341:          mAsmCntl1Reg |= AES_CTRL1_CTR;
  342:        }
  343:    
  344:        if(gAsmModeAes_c == mCipherMode)
  345:        {
  346:          mAsmCntl1Reg |= AES_CTRL1_AES;
  347:        } 
  348:      
  349:        /* Load the counter if necessary */
  350:        if((gAsmModeCtr_c == mCipherMode )|| (gAsmModeCcm_c == mCipherMode)) 
  351:        {
  352:          mAsmCntl2Reg = (mAsmCntl2Reg & mAsmCntl1RegModesMask_c) | AES_CTRL2_REGTYPE_CTR;
  353:          if(asmConfig.pCtr != NULL)
  354:          {        
  355:            MemoryCpy((void*)&mAsmD0Reg, asmConfig.pCtr, mAsmBlockSize_c);
  356:          }  
  357:          else
  358:          {
  359:            MemorySet((void*)&mAsmD0Reg, 0x00, mAsmBlockSize_c);
  360:          }
  361:        }   
  362:    
  363:  #else
  364:  
  365:      mpKey = asmConfig.pKey;
  007a 9efe07   [5]             LDHX  7,SP
  007d 960000   [5]             STHX  mpKey
  366:      mpCtr = asmConfig.pCtr;
  0080 9efe09   [5]             LDHX  9,SP
  0083 960000   [5]             STHX  mpCtr
  367:      mpMacAccPreload = asmConfig.pMacAccPreload;
  0086 9efe0f   [5]             LDHX  15,SP
  0089 960000   [5]             STHX  mpMacAccPreload
  368:      mAesRound = mFirstRound_c;
  008c ae01     [2]             LDX   #1
  008e cf0000   [4]             STX   mAesRound
  369:   
  370:  #endif
  371:  
  372:        mu8AsmState = gAsmStateCiphering_c;
  0091 cf0000   [4]             STX   mu8AsmState
  373:        
  374:        return gAsmErrNoError_c;   
  0094 65       [3]             SKIP2 L97 ;abs = 0097
  0095          L95:    
  375:      }
  376:    }
  377:      
  378:    else
  379:    {
  380:      return gAsmErrModuleBusy_c;
  0095 a601     [2]             LDA   #1
  0097          L97:    
  381:    }
  382:      
  383:  }
  0097 a703     [2]             AIS   #3
  0099 8d       [7]             RTC   
  384:  
  385:  
  386:  /************************************************************************************
  387:  * Asm_CipherProcess
  388:  *
  389:  * This function performs the cipher operation through a state machine, it calls the 
  390:  * local function mCipherDecipher function many times as the number of blocks of 128
  391:  * bits that are going to be ciphered for MC1323x platforms. For HCS08GT/GB  and 
  392:  * HCS08QE the mCipherDecipher function is called 8 times per block of 128 bits. 
  393:  *
  394:  ************************************************************************************/
  395:  
  396:  
  397:  asmErr_t Asm_CipherProcess(void)
  398:  { 
  399:  
  400:    asmErr_t asmError; 
  401:    
  402:    if(gAsmStateCiphering_c == mu8AsmState)
  0000 c60000   [4]             LDA   mu8AsmState
  0003 a101     [2]             CMP   #1
  0005 260d     [3]             BNE   L14 ;abs = 0014
  403:    {
  404:      asmError = mCipherDecipher();
  0007 ac000000 [8]             CALL  mCipherDecipher
  405:      if(gAsmErrNoError_c != asmError)
  000b 4d       [1]             TSTA  
  000c 2748     [3]             BEQ   L56 ;abs = 0056
  406:      {
  407:        mu8AsmState = gAsmStateFinal_c; 
  000e ae03     [2]             LDX   #3
  0010 cf0000   [4]             STX   mu8AsmState
  0013 8d       [7]             RTC   
  0014          L14:    
  408:      }
  409:    } 
  410:    
  411:    else if(gAsmStateFinishBlockCipher_c == mu8AsmState)
  0014 a102     [2]             CMP   #2
  0016 2630     [3]             BNE   L48 ;abs = 0048
  412:    {
  413:      mpData = mpData + mAsmBlockSize_c;
  0018 320000   [5]             LDHX  mpData
  001b af10     [2]             AIX   #16
  001d 960000   [5]             STHX  mpData
  414:      mBufferLength = mBufferLength - mAsmBlockSize_c;
  0020 450000   [3]             LDHX  @mBufferLength
  0023 f6       [3]             LDA   ,X
  0024 a010     [2]             SUB   #16
  0026 f7       [2]             STA   ,X
  415:  
  416:      if(mBufferLength > 0)
  0027 2718     [3]             BEQ   L41 ;abs = 0041
  417:      {
  418:        mu8AsmState = gAsmStateCiphering_c;
  0029 a601     [2]             LDA   #1
  002b c70000   [4]             STA   mu8AsmState
  419:        if((gAsmModeCbcMac_c == mCipherMode) || (gAsmModeCcm_c == mCipherMode))
  002e c10000   [4]             CMP   mCipherMode
  0031 2707     [3]             BEQ   L3A ;abs = 003a
  0033 c60000   [4]             LDA   mCipherMode
  0036 a102     [2]             CMP   #2
  0038 260c     [3]             BNE   L46 ;abs = 0046
  003a          L3A:    
  420:        {
  421:          mLoadCbcPrevMac = TRUE;
  003a a601     [2]             LDA   #1
  003c c70000   [4]             STA   mLoadCbcPrevMac
  422:        } 
  423:        
  424:      } 
  425:      else
  426:      {
  427:        mu8AsmState = gAsmStateFinal_c;
  428:      }
  429:      asmError = gAsmErrNoError_c;
  430:    } 
  003f 4f       [1]             CLRA  
  0040 8d       [7]             RTC   
  0041          L41:    
  0041 a603     [2]             LDA   #3
  0043 c70000   [4]             STA   mu8AsmState
  0046          L46:    
  0046 4f       [1]             CLRA  
  0047 8d       [7]             RTC   
  0048          L48:    
  431:    
  432:    else if (gAsmStateFinal_c == mu8AsmState) 
  0048 a103     [2]             CMP   #3
  004a 260a     [3]             BNE   L56 ;abs = 0056
  433:    {
  434:      mu8AsmState = gAsmStateIdle_c;
  004c 5f       [1]             CLRX  
  004d cf0000   [4]             STX   mu8AsmState
  435:      mCallbackFunc();
  0050 320000   [5]             LDHX  mCallbackFunc
  0053 87       [2]             PSHA  
  0054 fd       [5]             JSR   ,X
  0055 86       [3]             PULA  
  0056          L56:    
  436:    }
  437:    
  438:    
  439:    return asmError;
  440:  
  441:  }
  0056 8d       [7]             RTC   
  442:  
  443:  
  444:  /************************************************************************************
  445:  * mCipherDecipher
  446:  *
  447:  * The local mCipherDecipher function that cipher or decipher a block of 128 bits 
  448:  * using the ASM encryption engine.
  449:  *
  450:  ************************************************************************************/
  451:  
  452:  #ifdef gMc1323xPlatform_d
  453:  
  454:  asmErr_t mCipherDecipher(void)
  455:  {
  456:    
  457:    uint8_t timeoutCycles;
  458:    
  459:    if(mCcmSecondRound)
  460:    {
  461:      mAsmCntl1Reg &= ~AES_CTRL1_CTR; //Clear CTR mode    
  462:      mAsmCntl1Reg |= AES_CTRL1_CBC;  //Set CBC mode   
  463:    }
  464:    
  465:    /*Load MAC from previous block encryption*/
  466:    if(mLoadCbcPrevMac) 
  467:    {
  468:      mAsmCntl2Reg = (uint8_t)((mAsmCntl2Reg & mAsmCntl1RegModesMask_c) |\
  469:                     (uint8_t)AES_CTRL2_REGTYPE_MAC);
  470:      MemoryCpy((void*)&mAsmD0Reg, mpCbcMacVal, mAsmBlockSize_c);
  471:      mAsmCntl1Reg |= AES_CTRL1_LOADMAC;
  472:      mLoadCbcPrevMac = FALSE;  
  473:    }
  474:  
  475:    /* Load data to cipher in Data Register*/
  476:    mAsmCntl2Reg = (mAsmCntl2Reg & mAsmCntl1RegModesMask_c) | (uint8_t)AES_CTRL2_REGTYPE_DATA; 
  477:    MemoryCpy((void*)&mAsmD0Reg, mpData, mAsmBlockSize_c);
  478:     
  479:    mAsmCntl1Reg |= AES_CTRL1_START; 
  480:    
  481:    timeoutCycles = gAsmMaxAesEngineCycles;
  482:    while(!(mAsmCntl2Reg & AES_CTRL2_IRQFLAG) && (timeoutCycles--));
  483:    
  484:    if(!(mAsmCntl2Reg & AES_CTRL2_IRQFLAG))
  485:    {    
  486:      /* AES Operation timeout. Clear the AES mode bits */
  487:      mAsmCntl1Reg = AES_CTRL1_AESMSK;
  488:      return gAsmErrInternalTimeout_c; 
  489:    }
  490:    
  491:    /* clear the interrupt flag */
  492:    mAsmCntl2Reg |= AES_CTRL2_IRQFLAG;
  493:    
  494:    /* Cipher Operation completed succesfully. Copy the result in the provided location */
  495:    if(is_cbc_mode_selected())
  496:    {
  497:      mAsmCntl2Reg = (mAsmCntl2Reg & mAsmCntl1RegModesMask_c) | (uint8_t)AES_CTRL2_REGTYPE_CBCRES;
  498:      MemoryCpy(mpCbcMacVal, (void*)&mAsmD0Reg, mAsmBlockSize_c);
  499:    }
  500:    
  501:    if(is_ctr_mode_selected())
  502:    {      
  503:        mAsmCntl2Reg = (mAsmCntl2Reg & mAsmCntl1RegModesMask_c) | (uint8_t)AES_CTRL2_REGTYPE_CTRRES;
  504:        MemoryCpy(mpData, (void*)&mAsmD0Reg, mAsmBlockSize_c);
  505:    } 
  506:    
  507:    else if(gAsmModeAes_c == mCipherMode)  
  508:    {
  509:      mAsmCntl2Reg = (mAsmCntl2Reg & mAsmCntl1RegModesMask_c) | (uint8_t)AES_CTRL2_REGTYPE_AESRES;
  510:      MemoryCpy(mpData, (void*)&mAsmD0Reg, mAsmBlockSize_c);
  511:    }
  512:    
  513:    
  514:    if((gAsmModeCcm_c == mCipherMode) && (gAsmDecipher_c == mAsmAction))
  515:    {
  516:       if(mCcmSecondRound){
  517:         mCcmSecondRound = FALSE;
  518:         mu8AsmState = gAsmStateFinishBlockCipher_c;
  519:       } 
  520:       else
  521:       {
  522:         mCcmSecondRound = TRUE;
  523:         mu8AsmState = gAsmStateCiphering_c;
  524:       }
  525:    } 
  526:    else 
  527:    {    
  528:      mu8AsmState = gAsmStateFinishBlockCipher_c;
  529:    }
  530:    
  531:    return gAsmErrNoError_c;
  532:  }
  533:  
  534:  #else  //Other hcs08 platforms without hardware cipher engine
  535:  
  536:  /************************************************************************************
  537:  * mxTime
  538:  *
  539:  * This function is part of the mix column process.
  540:  *
  541:  ************************************************************************************/
  542:  
  543:  uint8_t mxTime(uint8_t x)
  544:  {
  545:    if(x & 0x80){
  0000 4d       [1]             TSTA  
  0001 2a04     [3]             BPL   L7 ;abs = 0007
  546:      return ((x << 1) ^ 0x1B); 
  0003 48       [1]             LSLA  
  0004 a81b     [2]             EOR   #27
  0006 8d       [7]             RTC   
  0007          L7:     
  547:    } 
  548:    else
  549:    {
  550:      return (x << 1);
  0007 48       [1]             LSLA  
  551:    }
  552:  }
  0008 8d       [7]             RTC   
  553:  
  554:  
  555:  /************************************************************************************
  556:  * mAesAddKeyByteSubShiftKeyExpand
  557:  *
  558:  * This function executes the subBytes, ShiftRows and expand key steps in the AES cipher
  559:  * process.
  560:  *
  561:  ************************************************************************************/
  562:  
  563:  void mAesAddKeyByteSubShiftKeyExpand(void)
  564:  {
  565:  	/* Add round key */
  566:    /* S-Box lookup */
  567:    /* Transformation */
  568:    /* Expand key */
  569:  
  570:    mAesState[0] = mSBox_c(mAesState[0]^mAesTempKey[0]);
  0000 c60000   [4]             LDA   mAesTempKey
  0003 c80000   [4]             EOR   mAesState
  0006 8c       [1]             CLRH  
  0007 97       [1]             TAX   
  0008 de0000   [4]             LDX   @mBox_c,X
  000b cf0000   [4]             STX   mAesState
  571:    mAesState[4] = mSBox_c(mAesState[4]^mAesTempKey[4]);
  000e c60004   [4]             LDA   mAesTempKey:4
  0011 c80004   [4]             EOR   mAesState:4
  0014 97       [1]             TAX   
  0015 de0000   [4]             LDX   @mBox_c,X
  0018 cf0004   [4]             STX   mAesState:4
  572:    mAesState[8] = mSBox_c(mAesState[8]^mAesTempKey[8]);
  001b c60008   [4]             LDA   mAesTempKey:8
  001e c80008   [4]             EOR   mAesState:8
  0021 97       [1]             TAX   
  0022 de0000   [4]             LDX   @mBox_c,X
  0025 cf0008   [4]             STX   mAesState:8
  573:    mAesState[12] = mSBox_c(mAesState[12]^mAesTempKey[12]);
  0028 c6000c   [4]             LDA   mAesTempKey:12
  002b c8000c   [4]             EOR   mAesState:12
  002e 97       [1]             TAX   
  002f de0000   [4]             LDX   @mBox_c,X
  0032 cf000c   [4]             STX   mAesState:12
  574:  
  575:    mAesTmp = mAesState[1]^mAesTempKey[1];
  0035 c60001   [4]             LDA   mAesTempKey:1
  0038 c80001   [4]             EOR   mAesState:1
  576:    mAesState[1] = mSBox_c(mAesState[5]^mAesTempKey[5]);
  003b 87       [2]             PSHA  
  003c c60005   [4]             LDA   mAesTempKey:5
  003f c80005   [4]             EOR   mAesState:5
  0042 97       [1]             TAX   
  0043 de0000   [4]             LDX   @mBox_c,X
  0046 cf0001   [4]             STX   mAesState:1
  577:    mAesState[5] = mSBox_c(mAesState[9]^mAesTempKey[9]);
  0049 c60009   [4]             LDA   mAesTempKey:9
  004c c80009   [4]             EOR   mAesState:9
  004f 97       [1]             TAX   
  0050 de0000   [4]             LDX   @mBox_c,X
  0053 cf0005   [4]             STX   mAesState:5
  578:    mAesState[9] = mSBox_c(mAesState[13]^mAesTempKey[13]);
  0056 c6000d   [4]             LDA   mAesTempKey:13
  0059 c8000d   [4]             EOR   mAesState:13
  005c 97       [1]             TAX   
  005d de0000   [4]             LDX   @mBox_c,X
  0060 cf0009   [4]             STX   mAesState:9
  579:    mAesState[13] = mSBox_c(mAesTmp);
  0063 88       [3]             PULX  
  0064 d60000   [4]             LDA   @mBox_c,X
  0067 c7000d   [4]             STA   mAesState:13
  580:  
  581:    mAesTmp = mAesState[2]^mAesTempKey[2];
  006a c60002   [4]             LDA   mAesTempKey:2
  006d c80002   [4]             EOR   mAesState:2
  582:    mAesState[2] = mSBox_c(mAesState[10]^mAesTempKey[10]);
  0070 87       [2]             PSHA  
  0071 c6000a   [4]             LDA   mAesTempKey:10
  0074 c8000a   [4]             EOR   mAesState:10
  0077 97       [1]             TAX   
  0078 de0000   [4]             LDX   @mBox_c,X
  007b cf0002   [4]             STX   mAesState:2
  583:    mAesState[10] = mSBox_c(mAesTmp);
  007e 88       [3]             PULX  
  007f d60000   [4]             LDA   @mBox_c,X
  0082 c7000a   [4]             STA   mAesState:10
  584:    mAesTmp = mAesState[6]^mAesTempKey[6];
  0085 c60006   [4]             LDA   mAesTempKey:6
  0088 c80006   [4]             EOR   mAesState:6
  585:    mAesState[6] = mSBox_c(mAesState[14]^mAesTempKey[14]);
  008b 87       [2]             PSHA  
  008c c6000e   [4]             LDA   mAesTempKey:14
  008f c8000e   [4]             EOR   mAesState:14
  0092 97       [1]             TAX   
  0093 de0000   [4]             LDX   @mBox_c,X
  0096 cf0006   [4]             STX   mAesState:6
  586:    mAesState[14] = mSBox_c(mAesTmp);
  0099 88       [3]             PULX  
  009a d60000   [4]             LDA   @mBox_c,X
  009d c7000e   [4]             STA   mAesState:14
  587:  
  588:    mAesTmp = mAesState[15]^mAesTempKey[15];
  00a0 c6000f   [4]             LDA   mAesTempKey:15
  00a3 c8000f   [4]             EOR   mAesState:15
  00a6 c70000   [4]             STA   mAesTmp
  589:    mAesState[15] = mSBox_c(mAesState[11]^mAesTempKey[11]);
  00a9 c6000b   [4]             LDA   mAesTempKey:11
  00ac c8000b   [4]             EOR   mAesState:11
  00af 97       [1]             TAX   
  00b0 de0000   [4]             LDX   @mBox_c,X
  00b3 cf000f   [4]             STX   mAesState:15
  590:    mAesState[11] = mSBox_c(mAesState[7]^mAesTempKey[7]);
  00b6 c60007   [4]             LDA   mAesTempKey:7
  00b9 c80007   [4]             EOR   mAesState:7
  00bc 97       [1]             TAX   
  00bd de0000   [4]             LDX   @mBox_c,X
  00c0 cf000b   [4]             STX   mAesState:11
  591:    mAesState[7] = mSBox_c(mAesState[3]^mAesTempKey[3]);
  00c3 c60003   [4]             LDA   mAesTempKey:3
  00c6 c80003   [4]             EOR   mAesState:3
  00c9 97       [1]             TAX   
  00ca de0000   [4]             LDX   @mBox_c,X
  00cd cf0007   [4]             STX   mAesState:7
  592:    mAesState[3] = mSBox_c(mAesTmp);
  00d0 ce0000   [4]             LDX   mAesTmp
  00d3 d60000   [4]             LDA   @mBox_c,X
  00d6 c70003   [4]             STA   mAesState:3
  593:  
  594:    /* Expand key */
  595:    
  596:    mAesTempKey[0] ^= mSBox_c(mAesTempKey[13]) ^ mAesRound;
  00d9 ce000d   [4]             LDX   mAesTempKey:13
  00dc c60000   [4]             LDA   mAesRound
  00df d80000   [4]             EOR   @mBox_c,X
  00e2 c80000   [4]             EOR   mAesTempKey
  00e5 c70000   [4]             STA   mAesTempKey
  597:    mAesTempKey[4] ^= mAesTempKey[0];
  00e8 c80004   [4]             EOR   mAesTempKey:4
  00eb c70004   [4]             STA   mAesTempKey:4
  598:    mAesTempKey[8] ^= mAesTempKey[4];
  00ee c80008   [4]             EOR   mAesTempKey:8
  00f1 c70008   [4]             STA   mAesTempKey:8
  599:    mAesTempKey[3] ^=  mSBox_c(mAesTempKey[12]);
  00f4 ce000c   [4]             LDX   mAesTempKey:12
  00f7 c60003   [4]             LDA   mAesTempKey:3
  00fa d80000   [4]             EOR   @mBox_c,X
  00fd c70003   [4]             STA   mAesTempKey:3
  600:    mAesTempKey[12] ^= mAesTempKey[8];
  0100 c60008   [4]             LDA   mAesTempKey:8
  0103 c8000c   [4]             EOR   mAesTempKey:12
  0106 c7000c   [4]             STA   mAesTempKey:12
  601:    mAesTempKey[1] ^= mSBox_c(mAesTempKey[14]);
  0109 ce000e   [4]             LDX   mAesTempKey:14
  010c c60001   [4]             LDA   mAesTempKey:1
  010f d80000   [4]             EOR   @mBox_c,X
  0112 c70001   [4]             STA   mAesTempKey:1
  602:    mAesTempKey[5] ^= mAesTempKey[1];
  0115 c80005   [4]             EOR   mAesTempKey:5
  0118 c70005   [4]             STA   mAesTempKey:5
  603:    mAesTempKey[9] ^= mAesTempKey[5];
  011b c80009   [4]             EOR   mAesTempKey:9
  011e c70009   [4]             STA   mAesTempKey:9
  604:    mAesTempKey[13] ^= mAesTempKey[9];
  0121 c8000d   [4]             EOR   mAesTempKey:13
  0124 c7000d   [4]             STA   mAesTempKey:13
  605:    mAesTempKey[2] ^= mSBox_c(mAesTempKey[15]);
  0127 ce000f   [4]             LDX   mAesTempKey:15
  012a c60002   [4]             LDA   mAesTempKey:2
  012d d80000   [4]             EOR   @mBox_c,X
  0130 450002   [3]             LDHX  @mAesTempKey:2
  0133 f7       [2]             STA   ,X
  606:    mAesTempKey[6] ^= mAesTempKey[2];
  0134 e804     [3]             EOR   4,X
  0136 e704     [3]             STA   4,X
  607:    mAesTempKey[10] ^= mAesTempKey[6];
  0138 e808     [3]             EOR   8,X
  013a e708     [3]             STA   8,X
  608:    mAesTempKey[14] ^= mAesTempKey[10];
  013c e80c     [3]             EOR   12,X
  013e e70c     [3]             STA   12,X
  609:    mAesTempKey[7] ^= mAesTempKey[3];
  0140 e601     [3]             LDA   1,X
  0142 e805     [3]             EOR   5,X
  0144 e705     [3]             STA   5,X
  610:    mAesTempKey[11] ^= mAesTempKey[7];
  0146 e809     [3]             EOR   9,X
  0148 e709     [3]             STA   9,X
  611:    mAesTempKey[15] ^= mAesTempKey[11]; 
  014a e80d     [3]             EOR   13,X
  014c e70d     [3]             STA   13,X
  612:   
  613:  }
  014e 8d       [7]             RTC   
  614:  
  615:  /************************************************************************************
  616:  * mAesMixColumn
  617:  *
  618:  * This function executes the mix columns step in the AES cipher process.
  619:  *
  620:  ************************************************************************************/
  621:  void mAesMixColumn(void)
  622:  {
  623:    uint8_t u8Count;
  624:    
  625:    for(u8Count=0;u8Count<mAsmBlockSize_c;u8Count = u8Count + 4){
  0000 5f       [1]             CLRX  
  0001          L1:     
  626:  	  mAesTmp = mAesState[0+u8Count];
  0001 8c       [1]             CLRH  
  0002 d60000   [4]             LDA   @mAesState,X
  0005 c70000   [4]             STA   mAesTmp
  627:  	  mAesTmp2 = mAesState[0+u8Count] ^ mAesState[1+u8Count] ^ mAesState[2+u8Count] ^ mAesState[3+u8Count];
  0008 d80001   [4]             EOR   @mAesState:1,X
  000b 87       [2]             PSHA  
  000c d80002   [4]             EOR   @mAesState:2,X
  000f d80003   [4]             EOR   @mAesState:3,X
  0012 c70000   [4]             STA   mAesTmp2
  628:  	  mAesState[0+u8Count] ^= mxTime(mAesState[0+u8Count] ^ mAesState[1+u8Count]) ^ mAesTmp2;
  0015 86       [3]             PULA  
  0016 89       [2]             PSHX  
  0017 ac000064 [8]             CALL  mAesMixColumn:100
  001b 9eee01   [4]             LDX   1,SP
  001e d80000   [4]             EOR   @mAesState,X
  0021 d70000   [4]             STA   @mAesState,X
  629:  	  mAesState[1+u8Count] ^= mxTime(mAesState[1+u8Count] ^ mAesState[2+u8Count]) ^ mAesTmp2;
  0024 d60002   [4]             LDA   @mAesState:2,X
  0027 d80001   [4]             EOR   @mAesState:1,X
  002a ac000064 [8]             CALL  mAesMixColumn:100
  002e 9eee01   [4]             LDX   1,SP
  0031 d80001   [4]             EOR   @mAesState:1,X
  0034 d70001   [4]             STA   @mAesState:1,X
  630:  	  mAesState[2+u8Count] ^= mxTime(mAesState[2+u8Count] ^ mAesState[3+u8Count]) ^ mAesTmp2;
  0037 d60003   [4]             LDA   @mAesState:3,X
  003a d80002   [4]             EOR   @mAesState:2,X
  003d ac000064 [8]             CALL  mAesMixColumn:100
  0041 9eee01   [4]             LDX   1,SP
  0044 d80002   [4]             EOR   @mAesState:2,X
  0047 d70002   [4]             STA   @mAesState:2,X
  631:  	  mAesState[3+u8Count] ^= mxTime(mAesState[3+u8Count] ^ mAesTmp) ^ mAesTmp2;
  004a c60000   [4]             LDA   mAesTmp
  004d d80003   [4]             EOR   @mAesState:3,X
  0050 ac000064 [8]             CALL  mAesMixColumn:100
  0054 88       [3]             PULX  
  0055 d80003   [4]             EOR   @mAesState:3,X
  0058 d70003   [4]             STA   @mAesState:3,X
  005b 9f       [1]             TXA   
  005c ab04     [2]             ADD   #4
  005e a110     [2]             CMP   #16
  0060 97       [1]             TAX   
  0061 259e     [3]             BCS   L1 ;abs = 0001
  632:    } 
  633:  
  634:  }
  0063 8d       [7]             RTC   
  0064          L64:    
  0064 ac000000 [8]             CALL  mxTime
  0068 c80000   [4]             EOR   mAesTmp2
  006b 8c       [1]             CLRH  
  006c 8d       [7]             RTC   
  635:  
  636:  /************************************************************************************
  637:  * mCipherDecipher
  638:  *
  639:  * Software implementation of the AES (Advanced Encryption Standard) cipher operation
  640:  * and cipher and decipher CTR, CBC and CCM  modes. Only the cipher AES process is 
  641:  * implemented. AES decipher function is not implemented.
  642:  *
  643:  ************************************************************************************/
  644:  
  645:  asmErr_t mCipherDecipher(void)
  646:  {
  0000 a7fe     [2]             AIS   #-2
  647:    uint8_t  u8Count;
  648:    uint8_t  u8TempResult;
  649:    
  650:    if( mFirstRound_c == mAesRound ){
  0002 c60000   [4]             LDA   mAesRound
  0005 4a       [1]             DECA  
  0006 2703     [3]             BEQ   LB ;abs = 000b
  0008 cc00f1   [4]             JMP   LF1 ;abs = 00f1
  000b          LB:     
  651:      
  652:      for(u8Count=0; u8Count < mAsmBlockSize_c; u8Count++)
  000b 95       [2]             TSX   
  000c 7f       [4]             CLR   ,X
  000d          LD:     
  653:      {     
  654:        
  655:        mAesTempKey[u8Count] = mpKey[u8Count];
  000d f6       [3]             LDA   ,X
  000e cb0001   [4]             ADD   mpKey:1
  0011 87       [2]             PSHA  
  0012 4f       [1]             CLRA  
  0013 c90000   [4]             ADC   mpKey
  0016 87       [2]             PSHA  
  0017 8a       [3]             PULH  
  0018 88       [3]             PULX  
  0019 fe       [3]             LDX   ,X
  001a 9f       [1]             TXA   
  001b 95       [2]             TSX   
  001c fe       [3]             LDX   ,X
  001d 8c       [1]             CLRH  
  001e d70000   [4]             STA   @mAesTempKey,X
  656:        
  657:        if(gAsmModeAes_c == mCipherMode)
  0021 c60000   [4]             LDA   mCipherMode
  0024 a103     [2]             CMP   #3
  0026 2608     [3]             BNE   L30 ;abs = 0030
  658:        {
  659:          mAesState[u8Count] = mpData[u8Count];
  0028 9f       [1]             TXA   
  0029 ac0001d5 [8]             CALL  mCipherDecipher:469
  002d f6       [3]             LDA   ,X
  660:        } 
  002e 205c     [3]             BRA   L8C ;abs = 008c
  0030          L30:    
  661:        
  662:        else if(((gAsmModeCbcMac_c == mCipherMode) || (gAsmModeCcm_c == mCipherMode)) && \
  0030 410104   [4]             CBEQA #1,L37 ;abs = 0037
  0033 a102     [2]             CMP   #2
  0035 2623     [3]             BNE   L5A ;abs = 005a
  0037          L37:    
  0037 c60000   [4]             LDA   mLoadCbcPrevMac
  003a 271e     [3]             BEQ   L5A ;abs = 005a
  663:                 (mLoadCbcPrevMac)) 
  664:        {
  665:          mAesState[u8Count] = mpData[u8Count] ^ mpCbcMacVal[u8Count]; 
  003c 9f       [1]             TXA   
  003d cb0001   [4]             ADD   mpData:1
  0040 87       [2]             PSHA  
  0041 4f       [1]             CLRA  
  0042 c90000   [4]             ADC   mpData
  0045 87       [2]             PSHA  
  0046 95       [2]             TSX   
  0047 e602     [3]             LDA   2,X
  0049 cb0001   [4]             ADD   mpCbcMacVal:1
  004c 87       [2]             PSHA  
  004d 4f       [1]             CLRA  
  004e c90000   [4]             ADC   mpCbcMacVal
  0051 87       [2]             PSHA  
  0052 8a       [3]             PULH  
  0053 88       [3]             PULX  
  0054 f6       [3]             LDA   ,X
  0055 8a       [3]             PULH  
  0056 88       [3]             PULX  
  0057 f8       [3]             EOR   ,X
  666:        } 
  0058 2032     [3]             BRA   L8C ;abs = 008c
  005a          L5A:    
  667:        
  668:        else if(is_ctr_mode_selected())
  005a c60000   [4]             LDA   mCipherMode
  005d 271f     [3]             BEQ   L7E ;abs = 007e
  005f a102     [2]             CMP   #2
  0061 260a     [3]             BNE   L6D ;abs = 006d
  0063 c60000   [4]             LDA   mAsmAction
  0066 2605     [3]             BNE   L6D ;abs = 006d
  0068 c60000   [4]             LDA   mCcmSecondRound
  006b 2611     [3]             BNE   L7E ;abs = 007e
  006d          L6D:    
  006d c60000   [4]             LDA   mCipherMode
  0070 a102     [2]             CMP   #2
  0072 261a     [3]             BNE   L8E ;abs = 008e
  0074 c60000   [4]             LDA   mAsmAction
  0077 4b15     [4]             DBNZA L8E ;abs = 008e
  0079 c60000   [4]             LDA   mCcmSecondRound
  007c 2610     [3]             BNE   L8E ;abs = 008e
  007e          L7E:    
  669:        {
  670:           mAesState[u8Count] = mpCtr[u8Count];
  007e 9f       [1]             TXA   
  007f cb0001   [4]             ADD   mpCtr:1
  0082 87       [2]             PSHA  
  0083 4f       [1]             CLRA  
  0084 c90000   [4]             ADC   mpCtr
  0087 87       [2]             PSHA  
  0088 8a       [3]             PULH  
  0089 88       [3]             PULX  
  008a fe       [3]             LDX   ,X
  008b 9f       [1]             TXA   
  008c          L8C:    
  671:        } 
  008c 204f     [3]             BRA   LDD ;abs = 00dd
  008e          L8E:    
  672:       
  673:        else if(is_cbc_mode_selected())
  008e c60000   [4]             LDA   mCipherMode
  0091 41011f   [4]             CBEQA #1,LB3 ;abs = 00b3
  0094 a102     [2]             CMP   #2
  0096 260a     [3]             BNE   LA2 ;abs = 00a2
  0098 c60000   [4]             LDA   mAsmAction
  009b 2605     [3]             BNE   LA2 ;abs = 00a2
  009d c60000   [4]             LDA   mCcmSecondRound
  00a0 2711     [3]             BEQ   LB3 ;abs = 00b3
  00a2          LA2:    
  00a2 c60000   [4]             LDA   mCipherMode
  00a5 a102     [2]             CMP   #2
  00a7 263a     [3]             BNE   LE3 ;abs = 00e3
  00a9 c60000   [4]             LDA   mAsmAction
  00ac 4b35     [4]             DBNZA LE3 ;abs = 00e3
  00ae c60000   [4]             LDA   mCcmSecondRound
  00b1 2730     [3]             BEQ   LE3 ;abs = 00e3
  00b3          LB3:    
  674:        {
  675:          if(NULL != mpMacAccPreload) 
  00b3 320000   [5]             LDHX  mpMacAccPreload
  00b6 271d     [3]             BEQ   LD5 ;abs = 00d5
  676:          {
  677:            mAesState[u8Count] = mpData[u8Count] ^ mpMacAccPreload[u8Count];
  00b8 95       [2]             TSX   
  00b9 f6       [3]             LDA   ,X
  00ba cb0001   [4]             ADD   mpData:1
  00bd 87       [2]             PSHA  
  00be 4f       [1]             CLRA  
  00bf c90000   [4]             ADC   mpData
  00c2 87       [2]             PSHA  
  00c3 f6       [3]             LDA   ,X
  00c4 cb0001   [4]             ADD   mpMacAccPreload:1
  00c7 87       [2]             PSHA  
  00c8 4f       [1]             CLRA  
  00c9 c90000   [4]             ADC   mpMacAccPreload
  00cc 87       [2]             PSHA  
  00cd 8a       [3]             PULH  
  00ce 88       [3]             PULX  
  00cf f6       [3]             LDA   ,X
  00d0 8a       [3]             PULH  
  00d1 88       [3]             PULX  
  00d2 f8       [3]             EOR   ,X
  678:          } 
  00d3 2008     [3]             BRA   LDD ;abs = 00dd
  00d5          LD5:    
  679:          else
  680:          {
  681:            mAesState[u8Count] = mpData[u8Count];
  00d5 95       [2]             TSX   
  00d6 f6       [3]             LDA   ,X
  00d7 ac0001d5 [8]             CALL  mCipherDecipher:469
  00db fe       [3]             LDX   ,X
  00dc 9f       [1]             TXA   
  00dd          LDD:    
  00dd 95       [2]             TSX   
  00de fe       [3]             LDX   ,X
  00df 8c       [1]             CLRH  
  00e0 d70000   [4]             STA   @mAesState,X
  00e3          LE3:    
  00e3 95       [2]             TSX   
  00e4 7c       [4]             INC   ,X
  00e5 f6       [3]             LDA   ,X
  00e6 a110     [2]             CMP   #16
  00e8 2403     [3]             BCC   LED ;abs = 00ed
  00ea cc000d   [4]             JMP   LD ;abs = 000d
  00ed          LED:    
  682:          }
  683:          
  684:        }
  685:        
  686:      }
  687:      
  688:      mLoadCbcPrevMac = FALSE; 
  00ed 4f       [1]             CLRA  
  00ee c70000   [4]             STA   mLoadCbcPrevMac
  00f1          LF1:    
  689:    }
  690:    
  691:    if(mAesLastRound_c != mAesRound)
  00f1 c60000   [4]             LDA   mAesRound
  00f4 413623   [4]             CBEQA #54,L11A ;abs = 011a
  692:    {
  693:      mAesAddKeyByteSubShiftKeyExpand();
  00f7 ac000000 [8]             CALL  mAesAddKeyByteSubShiftKeyExpand
  694:      mAesMixColumn();
  00fb ac000000 [8]             CALL  mAesMixColumn
  695:      
  696:      if( mEighthRound_c == mAesRound )
  00ff c60000   [4]             LDA   mAesRound
  0102 a180     [2]             CMP   #-128
  0104 2604     [3]             BNE   L10A ;abs = 010a
  697:      {
  698:        mAesRound = mNinthRound_c;       
  0106 a61b     [2]             LDA   #27
  699:      } 
  0108 2006     [3]             BRA   L110 ;abs = 0110
  010a          L10A:   
  700:       
  701:      else if( mNinthRound_c == mAesRound)
  010a a11b     [2]             CMP   #27
  010c 2605     [3]             BNE   L113 ;abs = 0113
  702:      {
  703:        mAesRound = mAesLastRound_c;
  010e a636     [2]             LDA   #54
  0110          L110:   
  704:      } 
  0110 cc01be   [4]             JMP   L1BE ;abs = 01be
  0113          L113:   
  705:      else{
  706:        mAesRound = mAesRound << 1;
  0113 450000   [3]             LDHX  @mAesRound
  0116 78       [4]             LSL   ,X
  0117 cc01c1   [4]             JMP   L1C1 ;abs = 01c1
  011a          L11A:   
  707:      }
  708:    } 
  709:     
  710:    else   // Last round
  711:    { 
  712:      mAesAddKeyByteSubShiftKeyExpand();
  011a ac000000 [8]             CALL  mAesAddKeyByteSubShiftKeyExpand
  713:      for(u8Count=0; u8Count < mAsmBlockSize_c; u8Count++)
  011e 95       [2]             TSX   
  011f 7f       [4]             CLR   ,X
  0120          L120:   
  714:      {
  715:        
  716:        u8TempResult = mAesState[u8Count] ^ mAesTempKey[u8Count];
  0120 fe       [3]             LDX   ,X
  0121 8c       [1]             CLRH  
  0122 d60000   [4]             LDA   @mAesTempKey,X
  0125 d80000   [4]             EOR   @mAesState,X
  0128 9ee702   [4]             STA   2,SP
  717:        
  718:        if(is_ctr_mode_selected())
  012b c60000   [4]             LDA   mCipherMode
  012e 271f     [3]             BEQ   L14F ;abs = 014f
  0130 a102     [2]             CMP   #2
  0132 260a     [3]             BNE   L13E ;abs = 013e
  0134 c60000   [4]             LDA   mAsmAction
  0137 2605     [3]             BNE   L13E ;abs = 013e
  0139 c60000   [4]             LDA   mCcmSecondRound
  013c 2611     [3]             BNE   L14F ;abs = 014f
  013e          L13E:   
  013e c60000   [4]             LDA   mCipherMode
  0141 a102     [2]             CMP   #2
  0143 2611     [3]             BNE   L156 ;abs = 0156
  0145 c60000   [4]             LDA   mAsmAction
  0148 4b0c     [4]             DBNZA L156 ;abs = 0156
  014a c60000   [4]             LDA   mCcmSecondRound
  014d 2607     [3]             BNE   L156 ;abs = 0156
  014f          L14F:   
  014f ac0001c5 [8]             CALL  mCipherDecipher:453
  719:        {
  720:          mpData[u8Count] = mpData[u8Count] ^ u8TempResult;
  0153 f8       [3]             EOR   ,X
  721:        } 
  0154 2041     [3]             BRA   L197 ;abs = 0197
  0156          L156:   
  722:        
  723:        else if( is_cbc_mode_selected() )
  0156 c60000   [4]             LDA   mCipherMode
  0159 41011f   [4]             CBEQA #1,L17B ;abs = 017b
  015c a102     [2]             CMP   #2
  015e 260a     [3]             BNE   L16A ;abs = 016a
  0160 c60000   [4]             LDA   mAsmAction
  0163 2605     [3]             BNE   L16A ;abs = 016a
  0165 c60000   [4]             LDA   mCcmSecondRound
  0168 2711     [3]             BEQ   L17B ;abs = 017b
  016a          L16A:   
  016a c60000   [4]             LDA   mCipherMode
  016d a102     [2]             CMP   #2
  016f 261b     [3]             BNE   L18C ;abs = 018c
  0171 c60000   [4]             LDA   mAsmAction
  0174 4b16     [4]             DBNZA L18C ;abs = 018c
  0176 c60000   [4]             LDA   mCcmSecondRound
  0179 2711     [3]             BEQ   L18C ;abs = 018c
  017b          L17B:   
  724:        {
  725:          mpCbcMacVal[u8Count] = u8TempResult;
  017b 9f       [1]             TXA   
  017c cb0001   [4]             ADD   mpCbcMacVal:1
  017f 87       [2]             PSHA  
  0180 4f       [1]             CLRA  
  0181 c90000   [4]             ADC   mpCbcMacVal
  0184 87       [2]             PSHA  
  0185 95       [2]             TSX   
  0186 e603     [3]             LDA   3,X
  0188 8a       [3]             PULH  
  0189 88       [3]             PULX  
  726:        } 
  018a 200b     [3]             BRA   L197 ;abs = 0197
  018c          L18C:   
  727:        
  728:        else if (gAsmModeAes_c == mCipherMode){
  018c c60000   [4]             LDA   mCipherMode
  018f a103     [2]             CMP   #3
  0191 2605     [3]             BNE   L198 ;abs = 0198
  0193 ac0001c5 [8]             CALL  mCipherDecipher:453
  0197          L197:   
  729:          mpData[u8Count] = u8TempResult;
  0197 f7       [2]             STA   ,X
  0198          L198:   
  0198 95       [2]             TSX   
  0199 7c       [4]             INC   ,X
  019a f6       [3]             LDA   ,X
  019b a110     [2]             CMP   #16
  019d 2581     [3]             BCS   L120 ;abs = 0120
  730:        }
  731:      }
  732:      
  733:      if((gAsmModeCcm_c == mCipherMode))
  019f c60000   [4]             LDA   mCipherMode
  01a2 a102     [2]             CMP   #2
  01a4 2611     [3]             BNE   L1B7 ;abs = 01b7
  734:      {
  735:         if(mCcmSecondRound){
  01a6 c60000   [4]             LDA   mCcmSecondRound
  01a9 2706     [3]             BEQ   L1B1 ;abs = 01b1
  736:           mCcmSecondRound = FALSE;
  01ab 4f       [1]             CLRA  
  01ac c70000   [4]             STA   mCcmSecondRound
  737:           mu8AsmState = gAsmStateFinishBlockCipher_c;
  738:         } 
  01af 2006     [3]             BRA   L1B7 ;abs = 01b7
  01b1          L1B1:   
  739:         else
  740:         {
  741:           mCcmSecondRound = TRUE;
  01b1 a601     [2]             LDA   #1
  01b3 c70000   [4]             STA   mCcmSecondRound
  01b6 65       [3]             SKIP2 L1B9 ;abs = 01b9
  01b7          L1B7:   
  742:           mu8AsmState = gAsmStateCiphering_c;
  743:         }
  744:      } 
  745:      else 
  746:      {    
  747:        mu8AsmState = gAsmStateFinishBlockCipher_c;
  01b7 a602     [2]             LDA   #2
  01b9          L1B9:   
  01b9 c70000   [4]             STA   mu8AsmState
  748:      }
  749:      
  750:      mAesRound = mFirstRound_c;
  01bc a601     [2]             LDA   #1
  01be          L1BE:   
  01be c70000   [4]             STA   mAesRound
  01c1          L1C1:   
  751:    }
  752:    return gAsmErrNoError_c;    
  01c1 4f       [1]             CLRA  
  753:  }
  01c2 a702     [2]             AIS   #2
  01c4 8d       [7]             RTC   
  01c5          L1C5:   
  01c5 9f       [1]             TXA   
  01c6 cb0001   [4]             ADD   mpData:1
  01c9 87       [2]             PSHA  
  01ca 4f       [1]             CLRA  
  01cb c90000   [4]             ADC   mpData
  01ce 87       [2]             PSHA  
  01cf 95       [2]             TSX   
  01d0 e606     [3]             LDA   6,X
  01d2 8a       [3]             PULH  
  01d3 88       [3]             PULX  
  01d4 8d       [7]             RTC   
  01d5          L1D5:   
  01d5 cb0001   [4]             ADD   mpData:1
  01d8 87       [2]             PSHA  
  01d9 4f       [1]             CLRA  
  01da c90000   [4]             ADC   mpData
  01dd 87       [2]             PSHA  
  01de 8a       [3]             PULH  
  01df 88       [3]             PULX  
  01e0 8d       [7]             RTC   
  754:  
  755:  #endif
  756:  
  757:  #else                            /* gAsmSupported_d == FALSE */
  758:  
  759:  /************************************************************************************
  760:  *************************************************************************************
  761:  * Public functions
  762:  *************************************************************************************
  763:  ************************************************************************************/
  764:  
  765:  /************************************************************************************
  766:  * Asm_Init
  767:  *
  768:  * This function is called to initialize the ASM driver, ASM control registers and
  769:  * to perform the AES self-test in the MC1323x platform. For HCS08GT/GB, MC1321x, 
  770:  * and HCS08QE platforms the function only initialize the state machine.
  771:  *
  772:  ************************************************************************************/
  773:  
  774:  
  775:  asmErr_t Asm_Init()
  776:  {   
  777:  
  778:      return gAsmErrNoError_c; 
  779:  }
  780:  
  781:  /************************************************************************************
  782:  * Asm_CipherDecipherRequest
  783:  *
  784:  * This function configures the cipher operation, set the key, counter, a preload MAC
  785:  * (Message Autentication Code) in the respective ASM registers. For platforms
  786:  * without a cipher engine it set the respective parameter in the arrays used for
  787:  * for the cipher opertation.
  788:  *
  789:  * Caution: The input data buffer is overridden with the ciphered or deciphered data.
  790:  * The buffer length must be multiple of 16 bytes or 128 bits.
  791:  *
  792:  ************************************************************************************/
  793:  
  794:  asmErr_t Asm_CipherDecipherRequest(
  795:  asmConfig_t asmConfig, 
  796:  uint8_t * pData, 
  797:  asmAction_t asmAction)
  798:  {
  799:      (void)asmConfig;
  800:      (void)pData;
  801:      (void)asmAction;                                                                       
  802:      return gAsmErrNoError_c;   
  803:      
  804:  }
  805:  
  806:  
  807:  /************************************************************************************
  808:  * Asm_CipherProcess
  809:  *
  810:  * This function performs the cipher operation through a state machine, it calls the 
  811:  * local function mCipherDecipher function many times as the number of blocks of 128
  812:  * bits that are going to be ciphered for MC1323x platforms. For HCS08GT/GB  and 
  813:  * HCS08QE the mCipherDecipher function is called 8 times per block of 128 bits. 
  814:  *
  815:  ************************************************************************************/
  816:  
  817:  
  818:  asmErr_t Asm_CipherProcess(void)
  819:  { 
  820:    return gAsmErrNoError_c;
  821:  
  822:  }
  823:  
  824:  
  825:  /************************************************************************************
  826:  * mCipherDecipher
  827:  *
  828:  * The local mCipherDecipher function that cipher or decipher a block of 128 bits 
  829:  * using the ASM encryption engine.
  830:  *
  831:  ************************************************************************************/
  832:  
  833:  #ifdef gMc1323xPlatform_d
  834:  
  835:  asmErr_t mCipherDecipher(void)
  836:  {
  837:    return gAsmErrNoError_c;
  838:  }
  839:  
  840:  #else  //Other hcs08 platforms without hardware cipher engine
  841:  
  842:  /************************************************************************************
  843:  * mxTime
  844:  *
  845:  * This function is part of the mix column process.
  846:  *
  847:  ************************************************************************************/
  848:  
  849:  uint8_t mxTime(uint8_t x)
  850:  {
  851:    (void)x;
  852:    return 0;
  853:  }
  854:  
  855:  
  856:  /************************************************************************************
  857:  * mAesAddKeyByteSubShiftKeyExpand
  858:  *
  859:  * This function executes the subBytes, ShiftRows and expand key steps in the AES cipher
  860:  * process.
  861:  *
  862:  ************************************************************************************/
  863:  
  864:  void mAesAddKeyByteSubShiftKeyExpand(void)
  865:  {
  866:  
  867:   
  868:  }
  869:  
  870:  /************************************************************************************
  871:  * mAesMixColumn
  872:  *
  873:  * This function executes the mix columns step in the AES cipher process.
  874:  *
  875:  ************************************************************************************/
  876:  void mAesMixColumn(void)
  877:  {
  878:    
  879:  }
  880:  
  881:  /************************************************************************************
  882:  * mCipherDecipher
  883:  *
  884:  * Software implementation of the AES (Advanced Encryption Standard) cipher operation
  885:  * and cipher and decipher CTR, CBC and CCM  modes. Only the cipher AES process is 
  886:  * implemented. AES decipher function is not implemented.
  887:  *
  888:  ************************************************************************************/
  889:  
  890:  asmErr_t mCipherDecipher(void)
  891:  {
  892:    return gAsmErrNoError_c;    
  893:  }
  894:  
  895:  #endif    
  896:  
  897:  
  898:  
  899:  #endif
  900:  
  901:  
  902:  
  903:  
