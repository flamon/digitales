ANSI-C/cC++ Compiler for HC08 V-5.0.39 Build 11346, Dec 13 2011

    1:  /*
    2:   * uMac.c
    3:   *
    4:   *  Created on: Nov 1, 2012
    5:   */
    6:  
    7:  
    8:  //Librerias
    9:  #include "McuInit.h"                /*CPU and System Clock related functions*/
   10:  #include "EmbeddedTypes.h"          /*Include special data types*/       
   11:  #include "SMAC_Interface.h"         /*Include all OTA functionality*/
   12:  #include "uMac.h"        			/*Include all OTA functionality*/
   13:  #include "app_config.h"
   14:  #include "OTAP_Interface.h"
   15:  #include "PLM_config.h"
   16:  
   17:  
   18:  //Definiciones
   19:  typedef enum{
   20:  	uMac_NoInit = 0,
   21:  	uMac_Init = 1,
   22:  	uMac_WaitRx = 2,
   23:  	uMac_Rx = 3,
   24:  	uMac_Tx = 4
   25:  } uMac_Engine_State;
   26:  
   27:  channels_t       bestChannel;
   28:  bool_t           bScanDone;
   29:  
   30:  static uMac_Engine_State uMac_Current_State;
   31:  static bool_t uMac_On = FALSE;
   32:  //static uint8_t uMac_Best_Channel;
   33:  
   34:  //Variables
   35:  static uint8_t gau8RxDataBuffer[130]; /* 123 bytes is the SDU max size in non
   36:                                           promiscuous mode. 
   37:                                           125 bytes is the SDU max size in 
   38:                                           promiscuous mode. 
   39:                                           You have to consider the SDU plus 5 more 
   40:                                           bytes for SMAC header and that the buffer 
   41:                                           can not be bigger than 130 */
   42:  static uint8_t gau8TxDataBuffer[128]; /* This buffer can be as big as the biggest
   43:                                           packet to transmit in the app plus 3 
   44:                                           bytes reserved for SMAC packet header.
   45:                                           The buffer can not be bigger than 128 */
   46:          
   47:  static txPacket_t * AppTxPacket;
   48:  static rxPacket_t * AppRxPacket;
   49:  
   50:  static uMac_Packet * uMac_RxPacket;
   51:  static uMac_Packet * uMac_TxPacket;
   52:  
   53:  bool_t			bTxDone;
   54:  bool_t			bRxDone;
   55:  bool_t			bDoTx;
   56:  bool_t			bToggle = TRUE;
   57:  
   58:  uMac_nodeType uMactype;
   59:  uint8_t uMacdest = 1, i = 0;
   60:  
   61:  uint16_t ChannelsToScan = 0xFFF;
   62:  uint8_t ChannelsEnergy[16];
   63:  channels_t Channels[] = {gChannel11_c, gChannel12_c, gChannel13_c, gChannel14_c, gChannel15_c,
   64:  			gChannel16_c, gChannel17_c, gChannel18_c, gChannel19_c, gChannel20_c, gChannel21_c,
   65:  			gChannel22_c, gChannel23_c, gChannel24_c, gChannel25_c, gChannel26_c};
   66:  
   67:  //Prototipos
   68:  //void MLMEScanComfirm(channels_t ClearestChann); //Poner tambien
   69:  void InitSmac(void); //Poner en memoria bankeada******
   70:  void uMac_Txf(void);
   71:  
   72:  void Init_uMac(/*uMac_nodeType type, uint8_t dest, uMac_txCallBack TxCallBack, uMac_rxCallBack RxCallBack*/) {
   73:  	uMac_On = TRUE;
  0000 a601     [2]             LDA   #1
  0002 c70000   [4]             STA   uMac_On
   74:  	//uMactype = type;
   75:  	//uMacdest = dest;
   76:  	InitSmac();
  0005 ac000000 [8]             CALL  InitSmac
   77:  	uMac_RxPacket = (uMac_Packet *)AppRxPacket->smacPdu.u8Data;
  0009 320000   [5]             LDHX  AppRxPacket
  000c af05     [2]             AIX   #5
  000e 960000   [5]             STHX  uMac_RxPacket
   78:  	uMac_TxPacket = (uMac_Packet *)AppTxPacket->smacPdu.u8Data;
  0011 320000   [5]             LDHX  AppTxPacket
  0014 af03     [2]             AIX   #3
  0016 960000   [5]             STHX  uMac_TxPacket
   79:  	uMac_Current_State = uMac_NoInit;
  0019 4f       [1]             CLRA  
  001a c70000   [4]             STA   uMac_Current_State
   80:  	//guardar tipo de nodo y callbacks
   81:  }
  001d 8d       [7]             RTC   
   82:  
   83:  void uMac_Txf() {
   84:  	bDoTx = TRUE;
  0000 a601     [2]             LDA   #1
  0002 c70000   [4]             STA   bDoTx
   85:  }
  0005 8d       [7]             RTC   
   86:  
   87:  void uMac_Engine(){	
   88:  	switch (uMac_Current_State) {
  0000 c60000   [4]             LDA   uMac_Current_State
  0003 a104     [2]             CMP   #4
  0005 2210     [3]             BHI   L17 ;abs = 0017
  0007 4d       [1]             TSTA  
  0008 270e     [3]             BEQ   L18 ;abs = 0018
  000a 41013f   [4]             CBEQA #1,L4C ;abs = 004c
  000d 41024a   [4]             CBEQA #2,L5A ;abs = 005a
  0010 a104     [2]             CMP   #4
  0012 2603     [3]             BNE   L17 ;abs = 0017
  0014 cc00ad   [4]             JMP   LAD ;abs = 00ad
  0017          L17:    
  0017 8d       [7]             RTC   
  0018          L18:    
   89:  		case uMac_NoInit:
   90:  			if(uMac_On == TRUE) {
  0018 c60000   [4]             LDA   uMac_On
  001b 4a       [1]             DECA  
  001c 2632     [3]             BNE   L50 ;abs = 0050
   91:  				uMac_On = FALSE;
  001e 4f       [1]             CLRA  
  001f c70000   [4]             STA   uMac_On
   92:  				(void) MLMESetChannelRequest(Channels[i++]);
  0022 c60000   [4]             LDA   i
  0025 97       [1]             TAX   
  0026 4c       [1]             INCA  
  0027 c70000   [4]             STA   i
  002a 8c       [1]             CLRH  
  002b d60000   [4]             LDA   @Channels,X
  002e ac000000 [8]             CALL  MLMESetChannelRequest
   93:  				uMac_TxPacket->Dest_Add = uMacdest;
  0032 c60000   [4]             LDA   uMacdest
  0035 320000   [5]             LDHX  uMac_TxPacket
  0038 e703     [3]             STA   3,X
   94:  				uMac_TxPacket->Packet_Type = 0;
  003a 6f01     [5]             CLR   1,X
   95:  				uMac_TxPacket->Pan_ID = 10;
  003c a60a     [2]             LDA   #10
  003e f7       [2]             STA   ,X
   96:  				uMac_TxPacket->Source_Add = 0;
  003f 6f02     [5]             CLR   2,X
   97:  				//for (;;) 
   98:  				(void) MCPSDataRequest(AppTxPacket);
  0041 320000   [5]             LDHX  AppTxPacket
  0044 ac000000 [8]             CALL  MCPSDataRequest
   99:  				//while (bTxDone != TRUE) {
  100:  				//	bTxDone = FALSE;
  101:  					uMac_Current_State = uMac_Init;
  0048 a601     [2]             LDA   #1
  004a 205d     [3]             BRA   LA9 ;abs = 00a9
  004c          L4C:    
  102:  				//}
  103:  			}
  104:  			break;
  105:  		case uMac_Init:
  106:  			if (bTxDone == TRUE) {
  004c c60000   [4]             LDA   bTxDone
  004f 4a       [1]             DECA  
  0050          L50:    
  0050 266c     [3]             BNE   LBE ;abs = 00be
  0052 ac0000bf [8]             CALL  uMac_Engine:191
  107:  				(void) MLMERXEnableRequest(AppRxPacket, 0); 
  108:  				uMac_Current_State = uMac_WaitRx;
  0056 a602     [2]             LDA   #2
  0058 204f     [3]             BRA   LA9 ;abs = 00a9
  005a          L5A:    
  109:  			}
  110:  			break;
  111:  		case uMac_WaitRx:
  112:  				if(bRxDone == TRUE) {
  005a c60000   [4]             LDA   bRxDone
  005d 4b38     [4]             DBNZA L97 ;abs = 0097
  113:  					bRxDone = FALSE;
  005f 4f       [1]             CLRA  
  0060 c70000   [4]             STA   bRxDone
  114:  					//Analizar el paquete
  115:  					if (AppRxPacket->rxStatus == rxSuccessStatus_c) {
  0063 320000   [5]             LDHX  AppRxPacket
  0066 ee01     [3]             LDX   1,X
  0068 8c       [1]             CLRH  
  0069 650002   [3]             CPHX  #2
  006c 2625     [3]             BNE   L93 ;abs = 0093
  116:  						if (uMac_RxPacket->Pan_ID == 10) {
  006e 320000   [5]             LDHX  uMac_RxPacket
  0071 f6       [3]             LDA   ,X
  0072 a10a     [2]             CMP   #10
  0074 261a     [3]             BNE   L90 ;abs = 0090
  117:  							if (bToggle == TRUE) {
  0076 c60000   [4]             LDA   bToggle
  0079 4b09     [4]             DBNZA L84 ;abs = 0084
  118:  								Led_PrintValue(0x08);
  007b a608     [2]             LDA   #8
  007d ac000000 [8]             CALL  Led_PrintValue
  119:  								bToggle = FALSE;
  0081 4f       [1]             CLRA  
  120:  							} else {
  0082 2007     [3]             BRA   L8B ;abs = 008b
  0084          L84:    
  121:  								Led_PrintValue(0x00);
  0084 4f       [1]             CLRA  
  0085 ac000000 [8]             CALL  Led_PrintValue
  122:  								bToggle = TRUE;
  0089 a601     [2]             LDA   #1
  008b          L8B:    
  008b c70000   [4]             STA   bToggle
  123:  							}
  124:  							if (uMac_RxPacket->Packet_Type != 0) {
  008e 2003     [3]             BRA   L93 ;abs = 0093
  0090          L90:    
  125:  								// Llamar a la callback
  126:  							}
  127:  						} else {
  128:  							uMac_Current_State = uMac_NoInit;
  0090 4f       [1]             CLRA  
  129:  							break;
  0091 2016     [3]             BRA   LA9 ;abs = 00a9
  0093          L93:    
  0093 ac0000bf [8]             CALL  uMac_Engine:191
  0097          L97:    
  130:  						}
  131:  					}
  132:  					
  133:  					(void) MLMERXEnableRequest(AppRxPacket, 0);
  134:  				}
  135:  				if (bDoTx == TRUE) {
  0097 c60000   [4]             LDA   bDoTx
  009a 4b22     [4]             DBNZA LBE ;abs = 00be
  136:  					bDoTx = FALSE;
  009c 4f       [1]             CLRA  
  009d c70000   [4]             STA   bDoTx
  137:  					(void) MCPSDataRequest(AppTxPacket);
  00a0 320000   [5]             LDHX  AppTxPacket
  00a3 ac000000 [8]             CALL  MCPSDataRequest
  138:  					uMac_Current_State = uMac_Tx;
  00a7 a604     [2]             LDA   #4
  00a9          LA9:    
  00a9 c70000   [4]             STA   uMac_Current_State
  00ac          LAC:    
  00ac 8d       [7]             RTC   
  00ad          LAD:    
  139:  				}
  140:  				
  141:  				break;
  142:  		case uMac_Tx:
  143:  			if(bTxDone == TRUE){
  00ad c60000   [4]             LDA   bTxDone
  00b0 4b0c     [4]             DBNZA LBE ;abs = 00be
  144:  				bTxDone = FALSE;
  00b2 4f       [1]             CLRA  
  00b3 c70000   [4]             STA   bTxDone
  145:  				uMac_Current_State = uMac_Init;
  00b6 4c       [1]             INCA  
  00b7 c70000   [4]             STA   uMac_Current_State
  00ba ac0000bf [8]             CALL  uMac_Engine:191
  00be          LBE:    
  146:  				(void) MLMERXEnableRequest(AppRxPacket, 0);
  147:  			}
  148:  			break;
  149:  	}
  150:  }
  00be 8d       [7]             RTC   
  00bf          LBF:    
  00bf 320000   [5]             LDHX  AppRxPacket
  00c2 89       [2]             PSHX  
  00c3 8b       [2]             PSHH  
  00c4 4f       [1]             CLRA  
  00c5 87       [2]             PSHA  
  00c6 87       [2]             PSHA  
  00c7 87       [2]             PSHA  
  00c8 87       [2]             PSHA  
  00c9 ac000000 [8]             CALL  MLMERXEnableRequest
  00cd a706     [2]             AIS   #6
  00cf 8d       [7]             RTC   
  151:  
  152:  /************************************************************************************
  153:  *
  154:  * InitSmac
  155:  *
  156:  ************************************************************************************/
  157:  void InitSmac(void)
  158:  {
  159:      AppTxPacket = (txPacket_t*)gau8TxDataBuffer;
  0000 450000   [3]             LDHX  @gau8TxDataBuffer
  0003 960000   [5]             STHX  AppTxPacket
  160:      AppRxPacket = (rxPacket_t*)gau8RxDataBuffer; 
  0006 450000   [3]             LDHX  @gau8RxDataBuffer
  0009 960000   [5]             STHX  AppRxPacket
  161:      AppRxPacket->u8MaxDataLength = gMaxSmacSDULenght_c;
  000c a67b     [2]             LDA   #123
  000e f7       [2]             STA   ,X
  162:      // AppTxPacket->smacPdu.u8Data[0] = 'T';
  163:     /* */
  164:      AppTxPacket->u8DataLength = 10;
  000f a60a     [2]             LDA   #10
  0011 450000   [3]             LDHX  @gau8TxDataBuffer
  0014 f7       [2]             STA   ,X
  165:      
  166:      
  167:      (void)MLMERadioInit();
  0015 ac000000 [8]             CALL  MLMERadioInit
  168:      (void)MLMESetClockRate(gClko16MHz_c);
  0019 4f       [1]             CLRA  
  001a ac000000 [8]             CALL  MLMESetClockRate
  169:      (void)MCU_UseExternalClock();
  001e ac000000 [8]             CALL  MCU_UseExternalClock
  170:      
  171:      (void)MLMESetTmrPrescale(gTimeBase250kHz_c);
  0022 a603     [2]             LDA   #3
  0024 ac000000 [8]             CALL  MLMESetTmrPrescale
  0028          L28:    
  172:      while (gErrorNoError_c != MLMESetChannelRequest(gDefaultChannelNumber_c));
  0028 a60f     [2]             LDA   #15
  002a ac000000 [8]             CALL  MLMESetChannelRequest
  002e 4d       [1]             TSTA  
  002f 26f7     [3]             BNE   L28 ;abs = 0028
  173:      (void)MLMEPAOutputAdjust(gDefaultOutputPower_c);
  0031 a608     [2]             LDA   #8
  0033 ac000000 [8]             CALL  MLMEPAOutputAdjust
  174:      (void)MLMEFEGainAdjust(gGainOffset_c);
  0037 a69b     [2]             LDA   #-101
  0039 ac000000 [8]             CALL  MLMEFEGainAdjust
  175:   }
  003d 8d       [7]             RTC   
  176:  
  177:  /* Place it in NON_BANKED memory */
  178:  #ifdef MEMORY_MODEL_BANKED
  179:  #pragma CODE_SEG __NEAR_SEG NON_BANKED
  180:  #else
  181:  #pragma CODE_SEG DEFAULT
  182:  #endif /* MEMORY_MODEL_BANKED */
  183:  
  184:  /************************************************************************************
  185:  * MLMEScanComfirm
  186:  * 
  187:  *
  188:  *
  189:  ************************************************************************************/
  190:  void MLMEScanComfirm(channels_t ClearestChann)
  191:  {
  192:    bestChannel = ClearestChann; 
  0000 c70000   [4]             STA   bestChannel
  193:    bScanDone = TRUE;
  0003 a601     [2]             LDA   #1
  0005 c70000   [4]             STA   bScanDone
  194:  }
  0008 81       [6]             RTS   
  195:  
  196:  /************************************************************************************
  197:  * MCPSDataIndication
  198:  * 
  199:  *
  200:  *
  201:  ************************************************************************************/
  202:  void MCPSDataIndication(rxPacket_t *gsRxPacket)
  203:  {  
  204:    //Otap_OpcMCPSDataIndication(gsRxPacket);
  205:    bRxDone = TRUE;
  0000 a601     [2]             LDA   #1
  0002 c70000   [4]             STA   bRxDone
  206:  }
  0005 81       [6]             RTS   
  207:  
  208:  /************************************************************************************
  209:  * MCPSDataComfirm
  210:  * 
  211:  *
  212:  *
  213:  ************************************************************************************/
  214:  void MCPSDataComfirm(txStatus_t TransmissionResult)
  215:  {  
  216:      //Otap_OpcMCPSDataComfirm(&TransmissionResult);
  217:      bTxDone = TRUE;
  0000 a601     [2]             LDA   #1
  0002 c70000   [4]             STA   bTxDone
  218:  }
  0005 81       [6]             RTS   
  219:  
  220:  void MLMEResetIndication(void)
  221:  {
  222:    
  223:  }
  0000 81       [6]             RTS   
  224:  
  225:  
  226:  void MLMEWakeComfirm(void)
  227:  {
  228:    
  229:  }
  0000 81       [6]             RTS   
  230:  
  231:  
  232:  #pragma CODE_SEG DEFAULT
