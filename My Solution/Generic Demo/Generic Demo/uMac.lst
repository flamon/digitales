ANSI-C/cC++ Compiler for HC08 V-5.0.39 Build 11346, Dec 13 2011

    1:  /*
    2:   * uMac.c
    3:   *
    4:   *  Created on: Nov 1, 2012
    5:   */
    6:  
    7:  #include "McuInit.h"                /*CPU and System Clock related functions*/
    8:  #include "EmbeddedTypes.h"          /*Include special data types*/       
    9:  #include "SMAC_Interface.h"         /*Include all OTA functionality*/
   10:  #include "uMac.h"                   /*Include all OTA functionality*/
   11:  #include "app_config.h"
   12:  #include "OTAP_Interface.h"
   13:  #include "PLM_config.h"
   14:  
   15:  
   16:  #define MyID 1
   17:  
   18:  typedef enum {
   19:      uMac_NoInit = 0,
   20:      uMac_Init = 1,
   21:      uMac_WaitRx = 2,
   22:      uMac_Rx = 3,
   23:      uMac_Tx = 4
   24:  } uMac_Engine_State;
   25:  
   26:  static uMac_Engine_State uMac_Current_State;
   27:  static bool_t uMac_On = FALSE;
   28:  
   29:  static uint8_t gau8RxDataBuffer[130]; /* 123 bytes is the SDU max size in non
   30:                                           promiscuous mode. 
   31:                                           125 bytes is the SDU max size in 
   32:                                           promiscuous mode. 
   33:                                           You have to consider the SDU plus 5 more 
   34:                                           bytes for SMAC header and that the buffer 
   35:                                           can not be bigger than 130 */
   36:  static uint8_t gau8TxDataBuffer[128]; /* This buffer can be as big as the biggest
   37:                                           packet to transmit in the app plus 3 
   38:                                           bytes reserved for SMAC packet header.
   39:                                           The buffer can not be bigger than 128 */
   40:          
   41:  static txPacket_t *AppTxPacket;
   42:  static rxPacket_t *AppRxPacket;
   43:  
   44:  static uMac_Packet *uMac_RxPacket;
   45:  static uMac_Packet *uMac_TxPacket;
   46:  
   47:  bool_t bTxDone, bRxDone, bScanDone, bDoTx;
   48:  uint8_t uMacbroad = 254, ui = 0, ChannelsEnergy[16];
   49:  uint16_t ChannelsToScan = 0xFFF;
   50:  channels_t bestChannel, Channels[] = {gChannel11_c, gChannel12_c, gChannel13_c, gChannel14_c, gChannel15_c,
   51:              gChannel16_c, gChannel17_c, gChannel18_c, gChannel19_c, gChannel20_c, gChannel21_c,
   52:              gChannel22_c, gChannel23_c, gChannel24_c, gChannel25_c, gChannel26_c};
   53:  
   54:  
   55:  void InitSmac (void);  // Poner en memoria bankeada
   56:  void uMac_Txf (void);
   57:  
   58:  void Init_uMac (void)
   59:  {
   60:      InitSmac();
  0000 ac000000 [8]             CALL  InitSmac
   61:  
   62:      uMac_On = TRUE;
  0004 a601     [2]             LDA   #1
  0006 c70000   [4]             STA   uMac_On
   63:      uMac_RxPacket = (uMac_Packet *)AppRxPacket->smacPdu.u8Data;
  0009 320000   [5]             LDHX  AppRxPacket
  000c af05     [2]             AIX   #5
  000e 960000   [5]             STHX  uMac_RxPacket
   64:      uMac_TxPacket = (uMac_Packet *)AppTxPacket->smacPdu.u8Data;
  0011 320000   [5]             LDHX  AppTxPacket
  0014 af03     [2]             AIX   #3
  0016 960000   [5]             STHX  uMac_TxPacket
   65:      uMac_Current_State = uMac_NoInit;
  0019 4f       [1]             CLRA  
  001a c70000   [4]             STA   uMac_Current_State
   66:  }
  001d 8d       [7]             RTC   
   67:  
   68:  void uMac_Txf (void)
   69:  {
   70:      bDoTx = TRUE;
  0000 a601     [2]             LDA   #1
  0002 c70000   [4]             STA   bDoTx
   71:  }
  0005 8d       [7]             RTC   
   72:  
   73:  void uMac_Engine (void)
   74:  {   
   75:      switch (uMac_Current_State) {
  0000 c60000   [4]             LDA   uMac_Current_State
  0003 a104     [2]             CMP   #4
  0005 2210     [3]             BHI   L17 ;abs = 0017
  0007 4d       [1]             TSTA  
  0008 270e     [3]             BEQ   L18 ;abs = 0018
  000a 410144   [4]             CBEQA #1,L51 ;abs = 0051
  000d 410262   [4]             CBEQA #2,L72 ;abs = 0072
  0010 a104     [2]             CMP   #4
  0012 2603     [3]             BNE   L17 ;abs = 0017
  0014 cc00e8   [4]             JMP   LE8 ;abs = 00e8
  0017          L17:    
  0017 8d       [7]             RTC   
  0018          L18:    
   76:      case uMac_NoInit:
   77:          if (uMac_On == TRUE) {
  0018 c60000   [4]             LDA   uMac_On
  001b 4a       [1]             DECA  
  001c 2701     [3]             BEQ   L1F ;abs = 001f
  001e 8d       [7]             RTC   
  001f          L1F:    
   78:              uMac_On = FALSE;
  001f 4f       [1]             CLRA  
  0020 c70000   [4]             STA   uMac_On
   79:              
   80:              if (ui == 16) {
  0023 c60000   [4]             LDA   ui
  0026 a110     [2]             CMP   #16
  0028 2604     [3]             BNE   L2E ;abs = 002e
   81:                  ui = 0;
  002a 4f       [1]             CLRA  
  002b c70000   [4]             STA   ui
  002e          L2E:    
   82:              }
   83:              
   84:              (void) MLMESetChannelRequest(Channels[0]);
  002e c60000   [4]             LDA   Channels
  0031 ac000000 [8]             CALL  MLMESetChannelRequest
   85:              //(void) MLMESetChannelRequest(gChannel11_c);
   86:              uMac_TxPacket->Dest_Add = uMacbroad;
  0035 c60000   [4]             LDA   uMacbroad
  0038 320000   [5]             LDHX  uMac_TxPacket
  003b e703     [3]             STA   3,X
   87:              uMac_TxPacket->Packet_Type = 0;
  003d 6f01     [5]             CLR   1,X
   88:              uMac_TxPacket->Pan_ID = 10;
  003f a60a     [2]             LDA   #10
  0041 f7       [2]             STA   ,X
   89:              uMac_TxPacket->Source_Add = MyID;
  0042 a601     [2]             LDA   #1
  0044 e702     [3]             STA   2,X
   90:              (void) MCPSDataRequest(AppTxPacket);
  0046 320000   [5]             LDHX  AppTxPacket
  0049 ac000000 [8]             CALL  MCPSDataRequest
   91:              uMac_Current_State = uMac_Init;
  004d a601     [2]             LDA   #1
  004f 201f     [3]             BRA   L70 ;abs = 0070
  0051          L51:    
   92:          }
   93:          break;
   94:      case uMac_Init:
   95:          if (bTxDone == TRUE) {
  0051 c60000   [4]             LDA   bTxDone
  0054 4a       [1]             DECA  
  0055 2701     [3]             BEQ   L58 ;abs = 0058
  0057 8d       [7]             RTC   
  0058          L58:    
   96:              bTxDone = FALSE;
  0058 4f       [1]             CLRA  
  0059 c70000   [4]             STA   bTxDone
   97:              (void) MLMERXEnableRequest(AppRxPacket, 0x00000001); 
  005c 320000   [5]             LDHX  AppRxPacket
  005f 89       [2]             PSHX  
  0060 8b       [2]             PSHH  
  0061 ae01     [2]             LDX   #1
  0063 8c       [1]             CLRH  
  0064 89       [2]             PSHX  
  0065 8b       [2]             PSHH  
  0066 87       [2]             PSHA  
  0067 87       [2]             PSHA  
  0068 ac000000 [8]             CALL  MLMERXEnableRequest
  006c a706     [2]             AIS   #6
   98:              uMac_Current_State = uMac_WaitRx;
  006e a602     [2]             LDA   #2
  0070          L70:    
  0070 2072     [3]             BRA   LE4 ;abs = 00e4
  0072          L72:    
   99:              // uMac_On = TRUE;
  100:              // uMac_Current_State = uMac_NoInit;
  101:          }
  102:          break;
  103:      case uMac_WaitRx:
  104:          if (bRxDone == TRUE) {
  0072 c60000   [4]             LDA   bRxDone
  0075 4b57     [4]             DBNZA LCE ;abs = 00ce
  105:              bRxDone = FALSE;
  0077 4f       [1]             CLRA  
  0078 c70000   [4]             STA   bRxDone
  106:              if (AppRxPacket->rxStatus == rxSuccessStatus_c) {
  007b 320000   [5]             LDHX  AppRxPacket
  007e e601     [3]             LDA   1,X
  0080 a102     [2]             CMP   #2
  0082 263c     [3]             BNE   LC0 ;abs = 00c0
  107:                  if (uMac_RxPacket->Pan_ID == 10) {
  0084 320000   [5]             LDHX  uMac_RxPacket
  0087 f6       [3]             LDA   ,X
  0088 a10a     [2]             CMP   #10
  008a 263a     [3]             BNE   LC6 ;abs = 00c6
  108:                      if (uMac_RxPacket->Dest_Add == MyID || uMac_RxPacket->Dest_Add == uMacbroad) {
  008c e603     [3]             LDA   3,X
  008e 410107   [4]             CBEQA #1,L98 ;abs = 0098
  0091 c60000   [4]             LDA   uMacbroad
  0094 e103     [3]             CMP   3,X
  0096 2636     [3]             BNE   LCE ;abs = 00ce
  0098          L98:    
  109:                          switch (uMac_RxPacket->Source_Add) {
  0098 320000   [5]             LDHX  uMac_RxPacket
  009b e602     [3]             LDA   2,X
  009d a103     [2]             CMP   #3
  009f 2219     [3]             BHI   LBA ;abs = 00ba
  00a1 410109   [4]             CBEQA #1,LAD ;abs = 00ad
  00a4 41020a   [4]             CBEQA #2,LB1 ;abs = 00b1
  00a7 a103     [2]             CMP   #3
  00a9 260f     [3]             BNE   LBA ;abs = 00ba
  00ab 2007     [3]             BRA   LB4 ;abs = 00b4
  00ad          LAD:    
  110:                          case 1:
  111:                              Led_PrintValue(0x08);
  00ad a608     [2]             LDA   #8
  112:                              break;
  00af 2005     [3]             BRA   LB6 ;abs = 00b6
  00b1          LB1:    
  113:                          case 2:
  114:                              Led_PrintValue(0x06);
  00b1 a606     [2]             LDA   #6
  115:                              break;
  00b3 65       [3]             SKIP2 LB6 ;abs = 00b6
  00b4          LB4:    
  116:                          case 3:
  117:                              Led_PrintValue(0x03);
  00b4 a603     [2]             LDA   #3
  00b6          LB6:    
  00b6 ac000000 [8]             CALL  Led_PrintValue
  00ba          LBA:    
  00ba ac0000fa [8]             CALL  uMac_Engine:250
  00be 200e     [3]             BRA   LCE ;abs = 00ce
  00c0          LC0:    
  118:                              break;
  119:                          }
  120:                          
  121:                          if (uMac_RxPacket->Packet_Type != 0) {
  122:                              // Llamar callback
  123:                          }
  124:                          
  125:                          (void) MLMERXEnableRequest(AppRxPacket, 0);
  126:                      }
  127:                  } else {
  128:                      uMac_Current_State = uMac_NoInit;
  129:                      uMac_On = TRUE;
  130:                  }
  131:              } else if (AppRxPacket->rxStatus == rxTimeOutStatus_c) {
  00c0 e601     [3]             LDA   1,X
  00c2 a103     [2]             CMP   #3
  00c4 2608     [3]             BNE   LCE ;abs = 00ce
  00c6          LC6:    
  132:                  uMac_Current_State = uMac_NoInit;
  00c6 4f       [1]             CLRA  
  00c7 c70000   [4]             STA   uMac_Current_State
  133:                  uMac_On = TRUE;
  00ca 4c       [1]             INCA  
  00cb c70000   [4]             STA   uMac_On
  00ce          LCE:    
  134:              }
  135:          }
  136:  
  137:          if (bDoTx == TRUE) {
  00ce c60000   [4]             LDA   bDoTx
  00d1 4b26     [4]             DBNZA LF9 ;abs = 00f9
  138:              bDoTx = FALSE;
  00d3 4f       [1]             CLRA  
  00d4 c70000   [4]             STA   bDoTx
  139:              (void) MLMERXDisableRequest();  // Deshabilitar la recepcion antes de transmitir (necesario por SMAC)
  00d7 ac000000 [8]             CALL  MLMERXDisableRequest
  140:              (void) MCPSDataRequest(AppTxPacket);
  00db 320000   [5]             LDHX  AppTxPacket
  00de ac000000 [8]             CALL  MCPSDataRequest
  141:              uMac_Current_State = uMac_Tx;
  00e2 a604     [2]             LDA   #4
  00e4          LE4:    
  00e4 c70000   [4]             STA   uMac_Current_State
  00e7 8d       [7]             RTC   
  00e8          LE8:    
  142:          }
  143:          
  144:          break;
  145:      case uMac_Tx:
  146:          if (bTxDone == TRUE) {
  00e8 c60000   [4]             LDA   bTxDone
  00eb 4b0c     [4]             DBNZA LF9 ;abs = 00f9
  147:              bTxDone = FALSE;
  00ed 4f       [1]             CLRA  
  00ee c70000   [4]             STA   bTxDone
  148:              uMac_Current_State = uMac_Init;
  00f1 4c       [1]             INCA  
  00f2 c70000   [4]             STA   uMac_Current_State
  00f5 ac0000fa [8]             CALL  uMac_Engine:250
  00f9          LF9:    
  149:              (void) MLMERXEnableRequest(AppRxPacket, 0);
  150:          }
  151:          break;
  152:      }
  153:  }
  00f9 8d       [7]             RTC   
  00fa          LFA:    
  00fa 320000   [5]             LDHX  AppRxPacket
  00fd 89       [2]             PSHX  
  00fe 8b       [2]             PSHH  
  00ff 4f       [1]             CLRA  
  0100 87       [2]             PSHA  
  0101 87       [2]             PSHA  
  0102 87       [2]             PSHA  
  0103 87       [2]             PSHA  
  0104 ac000000 [8]             CALL  MLMERXEnableRequest
  0108 a706     [2]             AIS   #6
  010a 8d       [7]             RTC   
  154:  
  155:  void InitSmac (void)
  156:  {
  157:      AppTxPacket = (txPacket_t *) gau8TxDataBuffer;
  0000 450000   [3]             LDHX  @gau8TxDataBuffer
  0003 960000   [5]             STHX  AppTxPacket
  158:      AppTxPacket->u8DataLength = 10;
  0006 a60a     [2]             LDA   #10
  0008 f7       [2]             STA   ,X
  159:  
  160:      AppRxPacket = (rxPacket_t *) gau8RxDataBuffer; 
  0009 450000   [3]             LDHX  @gau8RxDataBuffer
  000c 960000   [5]             STHX  AppRxPacket
  161:      AppRxPacket->u8MaxDataLength = gMaxSmacSDULenght_c;
  000f a67b     [2]             LDA   #123
  0011 f7       [2]             STA   ,X
  162:      
  163:      
  164:      (void)MLMERadioInit();
  0012 ac000000 [8]             CALL  MLMERadioInit
  165:      (void)MLMESetClockRate(gClko16MHz_c);
  0016 4f       [1]             CLRA  
  0017 ac000000 [8]             CALL  MLMESetClockRate
  166:      (void)MCU_UseExternalClock();
  001b ac000000 [8]             CALL  MCU_UseExternalClock
  167:      
  168:      (void)MLMESetTmrPrescale(gTimeBase250kHz_c);
  001f a603     [2]             LDA   #3
  0021 ac000000 [8]             CALL  MLMESetTmrPrescale
  0025          L25:    
  169:      while (gErrorNoError_c != MLMESetChannelRequest(gDefaultChannelNumber_c));
  0025 a60f     [2]             LDA   #15
  0027 ac000000 [8]             CALL  MLMESetChannelRequest
  002b 4d       [1]             TSTA  
  002c 26f7     [3]             BNE   L25 ;abs = 0025
  170:      (void)MLMEPAOutputAdjust(gDefaultOutputPower_c);
  002e a608     [2]             LDA   #8
  0030 ac000000 [8]             CALL  MLMEPAOutputAdjust
  171:      (void)MLMEFEGainAdjust(gGainOffset_c);
  0034 a69b     [2]             LDA   #-101
  0036 ac000000 [8]             CALL  MLMEFEGainAdjust
  172:   }
  003a 8d       [7]             RTC   
  173:  
  174:  // Place it in NON_BANKED memory
  175:  #ifdef MEMORY_MODEL_BANKED
  176:  #pragma CODE_SEG __NEAR_SEG NON_BANKED
  177:  #else
  178:  #pragma CODE_SEG DEFAULT
  179:  #endif /* MEMORY_MODEL_BANKED */
  180:  
  181:  void MLMEScanComfirm (channels_t ClearestChann)
  182:  {
  183:      bestChannel = ClearestChann; 
  0000 c70000   [4]             STA   bestChannel
  184:      bScanDone = TRUE;
  0003 a601     [2]             LDA   #1
  0005 c70000   [4]             STA   bScanDone
  185:  }
  0008 81       [6]             RTS   
  186:  
  187:  void MCPSDataIndication (rxPacket_t *gsRxPacket)
  188:  {  
  189:      bRxDone = TRUE;
  0000 a601     [2]             LDA   #1
  0002 c70000   [4]             STA   bRxDone
  190:  }
  0005 81       [6]             RTS   
  191:  
  192:  void MCPSDataComfirm (txStatus_t TransmissionResult)
  193:  {  
  194:      bTxDone = TRUE;
  0000 a601     [2]             LDA   #1
  0002 c70000   [4]             STA   bTxDone
  195:  }
  0005 81       [6]             RTS   
  196:  
  197:  void MLMEResetIndication(void) { }
  0000 81       [6]             RTS   
  198:  
  199:  void MLMEWakeComfirm(void) { }
  0000 81       [6]             RTS   
  200:  
  201:  #pragma CODE_SEG DEFAULT
  202:  
